{"mappings":"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","sources":["<anon>","web/src/main.ts","src/spd/parser.ts","src/spd/svg-renderer.ts"],"sourcesContent":["// web/src/main.ts\nclass $30ca700923f7cd7e$export$f9c837a54db411d extends Error {\n    constructor(message){\n        super(message);\n        this.name = this.constructor.name;\n    }\n}\nclass $30ca700923f7cd7e$export$eaf10ed6e5991cf8 extends $30ca700923f7cd7e$export$f9c837a54db411d {\n    constructor(){\n        super(\"\\u3053\\u306E\\u30B3\\u30DE\\u30F3\\u30C9\\u306F\\u5F15\\u6570\\u304C\\u5FC5\\u8981\\u3067\\u3059\");\n    }\n}\nclass $30ca700923f7cd7e$export$1d21b533e0dc3eed extends $30ca700923f7cd7e$export$f9c837a54db411d {\n    constructor(){\n        super(\"\\u3053\\u306E\\u30B3\\u30DE\\u30F3\\u30C9\\u306B\\u5F15\\u6570\\u306F\\u4E0D\\u8981\\u3067\\u3059\");\n    }\n}\nclass $30ca700923f7cd7e$export$d0be8b16a0056b4a extends $30ca700923f7cd7e$export$f9c837a54db411d {\n    constructor(){\n        super(\"\\u30A4\\u30F3\\u30C7\\u30F3\\u30C8\\u306E\\u6570\\u304C\\u4E0D\\u6B63\\u3067\\u3059\");\n    }\n}\nclass $30ca700923f7cd7e$export$1e06c21ce32643dc extends $30ca700923f7cd7e$export$f9c837a54db411d {\n    constructor(){\n        super(\"\\u672A\\u77E5\\u306E\\u30B3\\u30DE\\u30F3\\u30C9\\u3067\\u3059\");\n    }\n}\nclass $30ca700923f7cd7e$export$91a4fa3e8e7c8586 extends $30ca700923f7cd7e$export$f9c837a54db411d {\n    constructor(){\n        super(\"\\u4E0D\\u9069\\u5207\\u306Aelse\\u3067\\u3059\");\n    }\n}\nclass $30ca700923f7cd7e$export$773fc764960da4ba extends $30ca700923f7cd7e$export$f9c837a54db411d {\n    constructor(){\n        super(\"\\u4E0D\\u9069\\u5207\\u306Acase\\u304C\\u73FE\\u308C\\u307E\\u3057\\u305F\");\n    }\n}\nclass $30ca700923f7cd7e$export$a235ab136f3fda43 extends $30ca700923f7cd7e$export$f9c837a54db411d {\n    constructor(){\n        super(\"\\u65E2\\u306B\\u540C\\u540D\\u306ECase\\u304C\\u5B58\\u5728\\u3057\\u307E\\u3059\");\n    }\n}\nclass $30ca700923f7cd7e$export$ecfc75b1ea638281 extends $30ca700923f7cd7e$export$f9c837a54db411d {\n    constructor(message){\n        super(`\\u{5185}\\u{90E8}\\u{30A8}\\u{30E9}\\u{30FC}:${message}`);\n    }\n}\nclass $30ca700923f7cd7e$export$aeae85cd74b5f02 extends $30ca700923f7cd7e$export$f9c837a54db411d {\n    constructor(){\n        super(\"\\u4E88\\u671F\\u3057\\u306A\\u3044IO\\u30A8\\u30E9\\u30FC\\u304C\\u767A\\u751F\\u3057\\u307E\\u3057\\u305F\");\n    }\n}\n/**\r\n * パース中のコンテキストを扱うクラス。\r\n */ class $30ca700923f7cd7e$var$Context {\n    constructor(){\n        // 親のコンテキスト\n        this.parent = null;\n        // 深さ\n        this.depth = 0;\n        // ノードリスト\n        this.nodeList = [];\n        // コンテキストの追加状態\n        this.optionStatus = \"Default\";\n        // コンテキストの状態に結びつく引数\n        this.optionArg = null;\n    }\n}\n/**\r\n * SPD (Simple PAD Description) フォーマットのパーサー。\r\n */ // コメントを判定する正規表現オブジェクト\nconst $30ca700923f7cd7e$var$patternComment = /^\\s*(#.*)?$/;\nconst $30ca700923f7cd7e$var$DummyParseErrorReceiver = ()=>{\n    return false;\n};\n/**\r\n * 本文を処理する\r\n * @param context 現在のコンテキスト\r\n * @param body 本文\r\n */ const $30ca700923f7cd7e$var$handleBody = (context, body)=>{\n    // 状態の制御\n    if (context.nodeList.length > 0) {\n        const lnode = context.nodeList[context.nodeList.length - 1];\n        if (context.optionArg != null && lnode.type === \"switch\") {\n            const node = lnode;\n            node.cases.set(context.optionArg, null);\n            context.optionArg = null;\n        }\n    }\n    if (body.startsWith(\":\")) {\n        const parts = body.split(/[ \\t]+/);\n        // コマンド部分と引数部分を分離\n        const cmd = parts[0].substring(1); // コマンド名（例: \"call\", \"if\"）\n        const arg = parts.length > 1 ? body.substring(parts[0].length).trim() : null; // 引数\n        switch(cmd){\n            case \"call\":\n                if (!arg) throw new $30ca700923f7cd7e$export$eaf10ed6e5991cf8();\n                context.nodeList.push({\n                    type: \"call\",\n                    text: arg,\n                    childNode: null\n                });\n                context.optionStatus = \"Default\";\n                context.optionArg = null;\n                break;\n            case \"terminal\":\n                if (!arg) throw new $30ca700923f7cd7e$export$eaf10ed6e5991cf8();\n                context.nodeList.push({\n                    type: \"terminal\",\n                    text: arg\n                });\n                context.optionStatus = \"Default\";\n                context.optionArg = null;\n                break;\n            case \"comment\":\n                if (!arg) throw new $30ca700923f7cd7e$export$eaf10ed6e5991cf8();\n                context.nodeList.push({\n                    type: \"comment\",\n                    text: arg\n                });\n                context.optionStatus = \"Default\";\n                context.optionArg = null;\n                break;\n            case \"while\":\n                if (!arg) throw new $30ca700923f7cd7e$export$eaf10ed6e5991cf8();\n                context.nodeList.push({\n                    type: \"loop\",\n                    isWhile: true,\n                    text: arg,\n                    childNode: null\n                });\n                context.optionStatus = \"Default\";\n                context.optionArg = null;\n                break;\n            case \"dowhile\":\n                if (!arg) throw new $30ca700923f7cd7e$export$eaf10ed6e5991cf8();\n                context.nodeList.push({\n                    type: \"loop\",\n                    isWhile: false,\n                    text: arg,\n                    childNode: null\n                });\n                context.optionStatus = \"Default\";\n                context.optionArg = null;\n                break;\n            case \"if\":\n                if (!arg) throw new $30ca700923f7cd7e$export$eaf10ed6e5991cf8();\n                context.nodeList.push({\n                    type: \"if\",\n                    text: arg,\n                    trueNode: null,\n                    falseNode: null\n                });\n                context.optionStatus = \"Default\";\n                context.optionArg = null;\n                break;\n            case \"switch\":\n                if (!arg) throw new $30ca700923f7cd7e$export$eaf10ed6e5991cf8();\n                context.nodeList.push({\n                    type: \"switch\",\n                    text: arg,\n                    cases: new Map()\n                });\n                context.optionStatus = \"Default\";\n                context.optionArg = null;\n                break;\n            case \"else\":\n                {\n                    const lastIfNode = context.nodeList.length === 0 ? null : context.nodeList[context.nodeList.length - 1];\n                    if (lastIfNode === null || lastIfNode.type !== \"if\") throw new $30ca700923f7cd7e$export$91a4fa3e8e7c8586();\n                    if (arg !== null) throw new $30ca700923f7cd7e$export$1d21b533e0dc3eed();\n                    context.optionStatus = \"Else\";\n                    context.optionArg = null;\n                    break;\n                }\n            case \"case\":\n                {\n                    const lastSwitchNode = context.nodeList.length === 0 ? null : context.nodeList[context.nodeList.length - 1];\n                    if (lastSwitchNode === null || lastSwitchNode.type !== \"switch\") throw new $30ca700923f7cd7e$export$773fc764960da4ba();\n                    if (!arg) throw new $30ca700923f7cd7e$export$eaf10ed6e5991cf8();\n                    if (lastSwitchNode.cases.has(arg)) throw new $30ca700923f7cd7e$export$a235ab136f3fda43();\n                    context.optionStatus = \"Default\";\n                    context.optionArg = arg;\n                    break;\n                }\n            default:\n                throw new $30ca700923f7cd7e$export$1e06c21ce32643dc();\n        }\n    } else {\n        context.nodeList.push({\n            type: \"process\",\n            text: body,\n            childNode: null\n        });\n        context.optionStatus = \"Default\";\n        context.optionArg = null;\n    }\n};\n/**\r\n * 現在のコンテキストを確定し、親コンテキストに移動します。\r\n * @param context 現在のコンテキスト。\r\n * @returns 親コンテキスト。\r\n */ const $30ca700923f7cd7e$var$upToParent = (context)=>{\n    if (context === null) return null;\n    // 状態の制御\n    if (context.nodeList.length > 0) {\n        const lnode = context.nodeList[context.nodeList.length - 1];\n        if (context.optionArg != null && lnode.type === \"switch\") {\n            const node = lnode;\n            node.cases.set(context.optionArg, null);\n            context.optionArg = null;\n        }\n    }\n    if (context.parent === null) return null;\n    // 追加するノードを新規作成。\n    let newNode = null;\n    if (context.nodeList.length === 0) return context.parent;\n    else if (context.nodeList.length === 1) newNode = context.nodeList[0];\n    else {\n        const nodeList = {\n            type: \"nodeList\",\n            children: []\n        };\n        for(let i = 0; i < context.nodeList.length; i++)nodeList.children.push(context.nodeList[i]);\n        newNode = nodeList;\n    }\n    // ノードの追加先となるノード。\n    const pnode = context.parent.nodeList[context.parent.nodeList.length - 1];\n    // ノードの種類に応じてノードの追加先に追加。\n    switch(pnode.type){\n        case \"process\":\n            {\n                const processNode = pnode;\n                processNode.childNode = newNode;\n                break;\n            }\n        case \"loop\":\n            {\n                const loopNode = pnode;\n                loopNode.childNode = newNode;\n                break;\n            }\n        case \"call\":\n            {\n                const callNode = pnode;\n                callNode.childNode = newNode;\n                break;\n            }\n        case \"switch\":\n            {\n                const snode = pnode;\n                if (context.parent.optionArg !== null) snode.cases.set(context.parent.optionArg, newNode);\n                else throw new $30ca700923f7cd7e$export$ecfc75b1ea638281(\"optionArg is null when it shouldn't be for switch node.\");\n                break;\n            }\n        case \"if\":\n            {\n                const ifnode = pnode;\n                if (context.parent.optionStatus === \"Default\") ifnode.trueNode = newNode;\n                else if (context.parent.optionStatus === \"Else\") {\n                    if (ifnode.falseNode !== null) throw new $30ca700923f7cd7e$export$91a4fa3e8e7c8586();\n                    else ifnode.falseNode = newNode;\n                }\n                break;\n            }\n    }\n    // 親ノードの状態をリセットする。\n    context.parent.optionStatus = \"Default\";\n    context.parent.optionArg = null;\n    // 親ノードを返す。\n    return context.parent;\n};\nconst $30ca700923f7cd7e$export$98e6a39c04603d36 = (src, exr = $30ca700923f7cd7e$var$DummyParseErrorReceiver)=>{\n    // if(src == null) throw new IllegalArgumentException(\"src is null\"); // # diff TypeScriptではnullチェックは不要\n    // 先頭のコンテキスト\n    const rootContext = new $30ca700923f7cd7e$var$Context();\n    // 現在のコンテキスト\n    let context = rootContext;\n    // １行づつ読み込む\n    // ソースコードを行ごとに分割\n    const lines = src.split(/\\r?\\n/);\n    let lineNo = 0; // 現在の行番号\n    try {\n        while(lineNo < lines.length){\n            const line = lines[lineNo];\n            lineNo++;\n            // コメント行は読み飛ばし\n            if ($30ca700923f7cd7e$var$patternComment.test(line)) continue;\n            // 先頭のタブ数を数える。\n            let tabNum = 0;\n            for(let i = 0; i < line.length; ++i){\n                if (line.charAt(i) === \"\\t\") tabNum++;\n                else break;\n            }\n            try {\n                if (context === null) throw new $30ca700923f7cd7e$export$d0be8b16a0056b4a();\n                // 子コンテキストの作成処理を行う。\n                if (tabNum > 0 && context.nodeList.length === 0 || tabNum < 0) // 最初からタブがある場合は不正。\n                throw new $30ca700923f7cd7e$export$d0be8b16a0056b4a();\n                if (tabNum > context.depth) {\n                    // タブが増加した場合の処理\n                    // 正当性をチェックする。\n                    const parentNode = context.nodeList[context.nodeList.length - 1];\n                    if (tabNum > context.depth + 1 || parentNode && parentNode.type === \"comment\") // 親がコメントか２階層以上離れているのは不正。\n                    throw new $30ca700923f7cd7e$export$d0be8b16a0056b4a();\n                    if (parentNode.type === \"switch\" && context.optionArg == null) // 子を持たないタイプの場合は不正。\n                    throw new $30ca700923f7cd7e$export$d0be8b16a0056b4a();\n                    // 子コンテキストを生成する。\n                    const newContext = new $30ca700923f7cd7e$var$Context();\n                    newContext.parent = context;\n                    newContext.depth = context.depth + 1;\n                    context = newContext;\n                }\n                // タブが減少した際の処理\n                while(tabNum < context.depth){\n                    context = $30ca700923f7cd7e$var$upToParent(context);\n                    if (context === null) throw new $30ca700923f7cd7e$export$d0be8b16a0056b4a();\n                }\n                // 本文は行のデータをtrimしたものとする。\n                // 行末が @ の場合は複数行扱いとする。\n                let body = line.substring(tabNum); // タブの後の本体部分を抽出\n                if (body.endsWith(\"@\")) {\n                    let multiLineContent = body.substring(0, body.length - 1);\n                    while(lineNo < lines.length){\n                        const nextLine = lines[lineNo];\n                        lineNo++;\n                        // コメント行で止まる\n                        if ($30ca700923f7cd7e$var$patternComment.test(nextLine)) continue;\n                        // 行末に @ が間読み込む\n                        // 行末に @ がある間読み込む\n                        let nextLineTabNum = 0;\n                        for(let i = 0; i < nextLine.length; ++i){\n                            if (nextLine.charAt(i) === \"\\t\") nextLineTabNum++;\n                            else break;\n                        }\n                        const nextLineBody = nextLine.substring(nextLineTabNum);\n                        if (nextLineBody.endsWith(\"@\")) multiLineContent += `\\n${nextLineBody.substring(0, nextLineBody.length - 1)}`;\n                        else {\n                            multiLineContent += `\\n${nextLineBody}`;\n                            break;\n                        }\n                    }\n                    body = multiLineContent;\n                }\n                body = body.replace(/@/g, \"\\n\");\n                // 本文を処理する。\n                if (context !== null) $30ca700923f7cd7e$var$handleBody(context, body);\n                else throw new $30ca700923f7cd7e$export$d0be8b16a0056b4a(); // contextがnullの場合、これは不正な状態を示す\n            } catch (ex) {\n                if (ex instanceof $30ca700923f7cd7e$export$f9c837a54db411d) {\n                    if (exr(line, lineNo - 1, ex)) ;\n                    else throw ex;\n                } else throw ex;\n            }\n        }\n        // 先頭まで戻る\n        while(context != null)context = $30ca700923f7cd7e$var$upToParent(context);\n    } catch (ex) {\n        if (ex instanceof $30ca700923f7cd7e$export$f9c837a54db411d) throw ex; // テストと適切なエラーハンドリングのためにParseErrorを再スロー\n        else {\n            console.error(`\\u{884C} ${lineNo} \\u{3067}\\u{4E88}\\u{671F}\\u{3057}\\u{306A}\\u{3044}\\u{30A8}\\u{30E9}\\u{30FC}\\u{304C}\\u{767A}\\u{751F}\\u{3057}\\u{307E}\\u{3057}\\u{305F}: ${ex}`);\n            throw new $30ca700923f7cd7e$export$f9c837a54db411d(`\\u{4E88}\\u{671F}\\u{3057}\\u{306A}\\u{3044}\\u{30A8}\\u{30E9}\\u{30FC}: ${ex}`); // その他のエラーをラップ\n        }\n    }\n    // モデルを最終化して返す\n    if (rootContext.nodeList.length === 0) return null;\n    const topNode = {\n        type: \"nodeList\",\n        children: rootContext.nodeList\n    };\n    return topNode;\n};\n\n\n// デフォルトの描画オプション\nconst $6b098df580cc3f14$var$defaultRenderOptions = {\n    fontSize: 14,\n    fontFamily: \"sans-serif\",\n    margin: {\n        top: 20,\n        right: 20,\n        bottom: 20,\n        left: 20\n    },\n    boxPadding: {\n        top: 10,\n        right: 10,\n        bottom: 10,\n        left: 10\n    },\n    branchePadding: {\n        top: 5,\n        right: 5,\n        bottom: 5,\n        left: 5\n    },\n    strokeWidth: 1,\n    strokeColor: \"#000000\",\n    backgroundColor: \"#ffffff\",\n    baseBackgroundColor: null,\n    textColor: \"#000000\",\n    lineHeight: 1.2,\n    doubleLineWidth: 5,\n    switchNodeCaseWidth: 20,\n    connectorWidth: 2,\n    nodeListSpace: 10,\n    childNodeOffsetWidth: 20,\n    listRenderType: \"original\"\n};\nfunction $6b098df580cc3f14$export$b3890eb0ae9dca99(node, options) {\n    const mergedOptions = {\n        ...$6b098df580cc3f14$var$defaultRenderOptions,\n        ...options\n    };\n    if (!node) return \"\";\n    const fragment = $6b098df580cc3f14$var$renderNode(node, mergedOptions);\n    const svgWidth = fragment.width + mergedOptions.margin.left + mergedOptions.margin.right;\n    const svgHeight = fragment.height + mergedOptions.margin.top + mergedOptions.margin.bottom;\n    let svg = `<svg `;\n    svg += `width=\"${svgWidth}\" height=\"${svgHeight}\" `;\n    svg += `viewBox=\"0 0 ${svgWidth} ${svgHeight}\" `;\n    svg += `xmlns=\"http://www.w3.org/2000/svg\">`;\n    const baseFillColor = mergedOptions.baseBackgroundColor ?? \"none\";\n    svg += `<rect x=\"0\" y=\"0\" `;\n    svg += `width=\"${svgWidth}\" height=\"${svgHeight}\" `;\n    svg += `fill=\"${baseFillColor}\"/>`;\n    svg += $6b098df580cc3f14$var$renderTransformTranslateSvg(mergedOptions.margin.left, mergedOptions.margin.top, fragment.svg);\n    svg += `</svg>`;\n    return svg;\n}\n/**\r\n * ASTのノード種別に応じて、対応する描画関数を呼び出す\r\n */ function $6b098df580cc3f14$var$renderNode(node, options) {\n    switch(node.type){\n        case \"process\":\n            return $6b098df580cc3f14$var$renderProcessFragment(node, options);\n        case \"terminal\":\n            return $6b098df580cc3f14$var$renderTerminalFragment(node, options);\n        case \"nodeList\":\n            return $6b098df580cc3f14$var$renderListFragment(node, options);\n        case \"call\":\n            return $6b098df580cc3f14$var$renderCallFragment(node, options);\n        case \"loop\":\n            return $6b098df580cc3f14$var$renderLoopFragment(node, options);\n        case \"if\":\n            return $6b098df580cc3f14$var$renderIfFragment(node, options);\n        case \"switch\":\n            return $6b098df580cc3f14$var$renderSwitchFragment(node, options);\n        case \"comment\":\n            return $6b098df580cc3f14$var$renderCommentFragment(node, options);\n        // 他のノードタイプは後で追加\n        default:\n            return {\n                svg: \"\",\n                width: 0,\n                height: 0,\n                type: \"Unknown\"\n            }; // 未実装のノードタイプ\n    }\n}\n/**\r\n * 箱型ノードの描画処理\r\n */ function $6b098df580cc3f14$var$renderBoxFragment(node, options) {\n    const textMetrics = $6b098df580cc3f14$var$measureTextSvg(node.text, options);\n    let contentWidth = textMetrics.width;\n    let contentHeight = textMetrics.height;\n    let textOffsetX = options.boxPadding.left;\n    let textOffsetY = 0;\n    let svg = ``;\n    if (node.borderType === \"Box\") {\n        // 四角形のボックス\n        contentWidth += options.boxPadding.left + options.boxPadding.right;\n        contentHeight += options.boxPadding.top + options.boxPadding.bottom;\n        textOffsetY += options.boxPadding.top;\n        const fillColor = options.backgroundColor ?? \"none\";\n        svg += `<rect x=\"0\" y=\"0\" width=\"${contentWidth}\" height=\"${contentHeight}\" `;\n        svg += `stroke=\"${options.strokeColor}\" stroke-width=\"${options.strokeWidth}\" `;\n        svg += `fill=\"${fillColor}\"/>`;\n    } else if (node.borderType === \"WRound\") {\n        // 丸みを帯びた四角形\n        contentHeight += options.boxPadding.top + options.boxPadding.bottom;\n        textOffsetY += options.boxPadding.top;\n        const radius = contentHeight / 2; // 高さの半分を丸みの半径とする\n        contentWidth += contentHeight;\n        textOffsetX = radius;\n        const fillColor = options.backgroundColor ?? \"none\";\n        svg += `<rect x=\"0\" y=\"0\" width=\"${contentWidth}\" height=\"${contentHeight}\" `;\n        svg += `rx=\"${radius}\" ry=\"${radius}\" `;\n        svg += `stroke=\"${options.strokeColor}\" stroke-width=\"${options.strokeWidth}\" `;\n        svg += `fill=\"${fillColor}\"/>`;\n    } else // ボーダーなし\n    contentWidth += options.boxPadding.left + options.boxPadding.right;\n    if (node.drawLeftBar) // 左側二重線\n    svg += $6b098df580cc3f14$var$renderLineSvg(options.doubleLineWidth, 0, options.doubleLineWidth, contentHeight, options);\n    if (node.drawRightBar) // 右側二重線\n    svg += $6b098df580cc3f14$var$renderLineSvg(contentWidth - options.doubleLineWidth, 0, contentWidth - options.doubleLineWidth, contentHeight, options);\n    svg += $6b098df580cc3f14$var$renderTextSvg(node.text, textOffsetX, textOffsetY, options);\n    let childFragment = null;\n    if (node.childNode) {\n        childFragment = $6b098df580cc3f14$var$renderNode(node.childNode, options);\n        svg += $6b098df580cc3f14$var$renderTransformTranslateSvg(options.childNodeOffsetWidth + contentWidth, 0, childFragment.svg);\n        svg += $6b098df580cc3f14$var$renderLineSvg(contentWidth, 0, options.childNodeOffsetWidth + contentWidth, 0, options);\n    }\n    const totalWidth = contentWidth + (childFragment ? childFragment.width + options.childNodeOffsetWidth : 0);\n    const totalHeight = Math.max(contentHeight, childFragment ? childFragment.height : 0);\n    return {\n        svg: svg,\n        width: totalWidth,\n        height: totalHeight,\n        type: node.type\n    };\n}\n/**\r\n * コメントノードの描画\r\n */ function $6b098df580cc3f14$var$renderCommentFragment(node, options) {\n    const boxNode = {\n        type: \"Comment\",\n        text: `(${node.text})`,\n        childNode: null,\n        borderType: \"None\",\n        drawLeftBar: false,\n        drawRightBar: false\n    };\n    return $6b098df580cc3f14$var$renderBoxFragment(boxNode, options);\n}\n/**\r\n * ループノードの描画\r\n */ function $6b098df580cc3f14$var$renderLoopFragment(node, options) {\n    const boxNode = {\n        type: \"Loop\",\n        text: node.text,\n        childNode: node.childNode,\n        borderType: \"Box\",\n        drawLeftBar: node.isWhile,\n        drawRightBar: !node.isWhile\n    };\n    return $6b098df580cc3f14$var$renderBoxFragment(boxNode, options);\n}\n/**\r\n * 呼び出しノードの描画\r\n */ function $6b098df580cc3f14$var$renderCallFragment(node, options) {\n    const boxNode = {\n        type: \"Call\",\n        text: node.text,\n        childNode: node.childNode,\n        borderType: \"Box\",\n        drawLeftBar: true,\n        drawRightBar: true\n    };\n    return $6b098df580cc3f14$var$renderBoxFragment(boxNode, options);\n}\n/**\r\n * 処理ノードの描画\r\n */ function $6b098df580cc3f14$var$renderProcessFragment(node, options) {\n    const boxNode = {\n        type: \"Process\",\n        text: node.text,\n        childNode: node.childNode,\n        borderType: \"Box\",\n        drawLeftBar: false,\n        drawRightBar: false\n    };\n    return $6b098df580cc3f14$var$renderBoxFragment(boxNode, options);\n}\n/**\r\n * 端子ノードの描画\r\n */ function $6b098df580cc3f14$var$renderTerminalFragment(node, options) {\n    const boxNode = {\n        type: \"Terminal\",\n        text: node.text,\n        childNode: null,\n        borderType: \"WRound\",\n        drawLeftBar: false,\n        drawRightBar: false\n    };\n    return $6b098df580cc3f14$var$renderBoxFragment(boxNode, options);\n}\n// == Branchノードの描画関数群 ===\nfunction $6b098df580cc3f14$var$measureTextSvgForBranche(text, options) {\n    const textMetrics = $6b098df580cc3f14$var$measureTextSvg(text, options);\n    return {\n        width: textMetrics.width + options.branchePadding.left + options.branchePadding.right,\n        height: textMetrics.height + options.branchePadding.top + options.branchePadding.bottom\n    };\n}\nfunction $6b098df580cc3f14$var$renderTextSvgForBranche(text, posX, posY, options) {\n    return $6b098df580cc3f14$var$renderTextSvg(text, posX + options.branchePadding.left, posY + options.branchePadding.top, options);\n}\n/**\r\n * 分岐ノードの描画\r\n */ function $6b098df580cc3f14$var$renderBrancheFragment(node, options) {\n    // ケースの数が2未満の場合はダミーを追加する\n    if (node.branches.length < 2) while(node.branches.length < 2)node.branches.push({\n        label: \"\",\n        node: null\n    });\n    let svg = \"\";\n    const conditionSize = $6b098df580cc3f14$var$measureTextSvgForBranche(node.text, options);\n    const minHeight = conditionSize.height;\n    const x = 0;\n    const y = 0;\n    // labelw　<- ラベルの最大幅\n    // h <- ラベルと、サブビューの合計値\n    // subview <- サブビューの最大幅\n    let labelw = 0;\n    let subvieww = 0;\n    let h = 0;\n    let count = 0;\n    let lastdy = 0;\n    let lastldy = 0;\n    const brancheFragments = [];\n    const ymap = new Map();\n    for (const [index, branche] of node.branches.entries()){\n        const label = branche.label;\n        const labelSize = $6b098df580cc3f14$var$measureTextSvgForBranche(label, options);\n        const brancheFragment = branche.node ? $6b098df580cc3f14$var$renderNode(branche.node, options) : null;\n        // サブビューがない場合はサイズ = 0\n        const subViewSize = brancheFragment ? {\n            width: brancheFragment.width,\n            height: brancheFragment.height\n        } : {\n            width: 0,\n            height: 0\n        };\n        if (count !== node.branches.length - 1) subViewSize.height += options.nodeListSpace;\n        brancheFragments.push({\n            label: label,\n            fragment: brancheFragment\n        });\n        // ラベルの最大幅を更新\n        if (labelw < labelSize.width) labelw = labelSize.width;\n        // サブビューの最大幅を更新\n        if (subvieww < subViewSize.width) subvieww = subViewSize.width;\n        // ラベルに合わせて高さを更新\n        let uply, bottomly;\n        if (count === 0) {\n            uply = 0;\n            bottomly = labelSize.height;\n        } else if (count === node.branches.length - 1) {\n            uply = labelSize.height;\n            bottomly = 0;\n        } else {\n            uply = labelSize.height / 2;\n            bottomly = uply;\n        }\n        if (lastdy < uply) lastdy += uply - lastdy;\n        // ラベルが縦長い場合に調整\n        const minldy = lastldy > uply ? lastldy * 2 : uply * 2;\n        lastldy = bottomly;\n        if (minldy > lastdy) lastdy = minldy;\n        // 高さを更新\n        h += lastdy;\n        ymap.set(index, h);\n        // tmp <- 高さ追記分\n        if (bottomly > subViewSize.height) lastdy = bottomly;\n        else lastdy = subViewSize.height;\n        if (lastdy < minHeight && count < node.branches.length - 1) lastdy = minHeight;\n        count += 1;\n    }\n    h += lastdy;\n    // 描画\n    /**\r\n\t * A-----B1\r\n\t * |    /\r\n\t * |   C2\r\n\t * |    \\\r\n\t * |     B2\r\n\t * |    /\r\n\t * |   C3\r\n\t * |    \\\r\n\t * E-----B3\r\n\t */ let first = true;\n    let addChildLineWidth = false;\n    const poly = [];\n    let lasty = 0;\n    const boxRight = x + conditionSize.width + labelw + options.switchNodeCaseWidth;\n    poly.push({\n        x: x,\n        y: y\n    }); // Pos:A\n    for (const [index, brancheFragment] of brancheFragments.entries()){\n        const lh_temp = ymap.get(index);\n        const lh = lh_temp ? lh_temp : 0;\n        const ly = y + lh;\n        if (brancheFragment.fragment !== null) {\n            // brancheFragment.fragment の描画\n            svg += $6b098df580cc3f14$var$renderTransformTranslateSvg(boxRight + options.childNodeOffsetWidth, ly, brancheFragment.fragment.svg);\n            // 小要素への line の描画\n            svg += $6b098df580cc3f14$var$renderLineSvg(boxRight, ly, boxRight + options.childNodeOffsetWidth, ly, options);\n            // 小要素への line の分、最後に返す幅を増やす\n            addChildLineWidth = true;\n        }\n        if (!first) // Pos:C\n        poly.push({\n            x: boxRight - options.switchNodeCaseWidth,\n            y: (lasty + ly) / 2\n        });\n        poly.push({\n            x: boxRight,\n            y: ly\n        }); // Pos:B\n        first = false;\n        lasty = ly;\n    }\n    poly.push({\n        x: x,\n        y: lasty\n    }); // Pos:E\n    const polyPoints = poly.map((p)=>`${p.x},${p.y}`).join(\" \");\n    // polyの描画\n    const fillColor = options.backgroundColor ?? \"none\";\n    svg += `<polygon points=\"${polyPoints}\" `;\n    svg += `stroke=\"${options.strokeColor}\" `;\n    svg += `stroke-width=\"${options.strokeWidth}\" `;\n    svg += `fill=\"${fillColor}\"/>`;\n    for (const [index, brancheFragment] of brancheFragments.entries()){\n        const label = brancheFragment.label;\n        const lh_temp = ymap.get(index);\n        const lh = lh_temp ? lh_temp : 0;\n        let ly = y + lh;\n        const ls = $6b098df580cc3f14$var$measureTextSvgForBranche(label, options);\n        if (index >= node.branches.length - 1) ly -= ls.height;\n        else if (index > 0) ly -= ls.height / 2;\n        // label の描画\n        svg += $6b098df580cc3f14$var$renderTextSvgForBranche(label, x + conditionSize.width + labelw - ls.width, ly, options);\n    }\n    // node.text の描画\n    svg += $6b098df580cc3f14$var$renderTextSvgForBranche(node.text, x, lasty / 2 - conditionSize.height / 2, options);\n    return {\n        svg: svg,\n        width: boxRight + subvieww + (addChildLineWidth ? options.childNodeOffsetWidth : 0),\n        height: h,\n        type: node.type\n    };\n}\n/**\r\n * SWITCH分岐ノードの描画\r\n */ function $6b098df580cc3f14$var$renderSwitchFragment(node, options) {\n    const switchBrancheNode = {\n        text: node.text,\n        type: \"Switch\",\n        branches: []\n    };\n    for (const [label, caseNode] of node.cases.entries())switchBrancheNode.branches.push({\n        label: label.toString(),\n        node: caseNode\n    });\n    return $6b098df580cc3f14$var$renderBrancheFragment(switchBrancheNode, options);\n}\n/**\r\n * IF分岐ノードの描画\r\n */ function $6b098df580cc3f14$var$renderIfFragment(node, options) {\n    const ifBrancheNode = {\n        text: node.text,\n        type: \"If\",\n        branches: []\n    };\n    if (node.trueNode) ifBrancheNode.branches.push({\n        label: \"\",\n        node: node.trueNode\n    });\n    else ifBrancheNode.branches.push({\n        label: \"\",\n        node: null\n    });\n    if (node.falseNode) ifBrancheNode.branches.push({\n        label: \"\",\n        node: node.falseNode\n    });\n    else ifBrancheNode.branches.push({\n        label: \"\",\n        node: null\n    });\n    return $6b098df580cc3f14$var$renderBrancheFragment(ifBrancheNode, options);\n}\n// == ノード間の接続線の描画関数群 ===\n/**\r\n * 連結ノード（NodeListNode）の描画\r\n */ function $6b098df580cc3f14$var$renderListFragment(node, options) {\n    if (options.listRenderType === \"TerminalOffset\") return $6b098df580cc3f14$var$renderListFragmentTerminalOffset(node, options);\n    else return $6b098df580cc3f14$var$renderListFragmentOriginal(node, options);\n}\nfunction $6b098df580cc3f14$var$renderListFragmentOriginal(node, options) {\n    let totalHeight = 0;\n    let maxWidth = 0;\n    let currentY = 0;\n    let childrenSvg = \"\";\n    const childFragments = [];\n    // 子ノードを再帰的に描画し、サイズとSVGを収集\n    for (const child of node.children){\n        const childFragment = $6b098df580cc3f14$var$renderNode(child, options);\n        childFragments.push(childFragment);\n        totalHeight += childFragment.height;\n        maxWidth = Math.max(maxWidth, childFragment.width);\n    }\n    // 子ノードのSVGを配置し、接続線を描画\n    for(let i = 0; i < childFragments.length; i++){\n        const childFragment = childFragments[i];\n        // const xOffset = (maxWidth - childFragment.width) / 2; // 中央揃え\n        childrenSvg += $6b098df580cc3f14$var$renderTransformTranslateSvg(0, currentY, childFragment.svg);\n        // 接続線を描画 (最後のノード以外)\n        if (i < childFragments.length - 1) {\n            let startY = 0;\n            let endY = 0;\n            if (childFragment.type === \"Terminal\") startY = currentY + childFragment.height / 2;\n            else startY = currentY;\n            if (childFragments[i + 1].type === \"Terminal\") endY = currentY + childFragment.height + options.nodeListSpace + childFragments[i + 1].height / 2;\n            else endY = currentY + childFragment.height + options.nodeListSpace + childFragments[i + 1].height;\n            childrenSvg += $6b098df580cc3f14$var$renderLineSvg(0, startY, 0, endY, options);\n            totalHeight += options.nodeListSpace;\n        }\n        currentY += childFragment.height + options.nodeListSpace;\n    }\n    return {\n        svg: childrenSvg,\n        width: maxWidth,\n        height: totalHeight,\n        type: \"NodeList\"\n    };\n}\nfunction $6b098df580cc3f14$var$renderListFragmentTerminalOffset(node, options) {\n    let totalHeight = 0;\n    let maxWidth = 0;\n    let offsetX = 0;\n    let topAddWidth = 0;\n    let bottomAddWidth = 0;\n    let currentY = 0;\n    let childrenSvg = \"\";\n    const childFragments = [];\n    // 子ノードを再帰的に描画し、サイズとSVGを収集\n    for (const child of node.children){\n        const childFragment = $6b098df580cc3f14$var$renderNode(child, options);\n        childFragments.push(childFragment);\n        totalHeight += childFragment.height;\n        maxWidth = Math.max(maxWidth, childFragment.width);\n    }\n    const topChildFragment = childFragments[0];\n    if (topChildFragment.type === \"Terminal\") {\n        const topWidth = topChildFragment.width;\n        offsetX = topWidth / 2;\n    }\n    const bottomChildFragment = childFragments[childFragments.length - 1];\n    if (bottomChildFragment.type === \"Terminal\") {\n        const bottomWidth = bottomChildFragment.width;\n        const bottomOffset = bottomWidth / 2;\n        if (bottomOffset > offsetX) {\n            topAddWidth = bottomOffset - offsetX;\n            offsetX = bottomOffset;\n        } else bottomAddWidth = offsetX - bottomOffset;\n    }\n    // 子ノードのSVGを配置し、接続線を描画\n    for(let i = 0; i < childFragments.length; i++){\n        const childFragment = childFragments[i];\n        // const xOffset = (maxWidth - childFragment.width) / 2; // 中央揃え\n        if (i === 0) childrenSvg += $6b098df580cc3f14$var$renderTransformTranslateSvg(topAddWidth, currentY, childFragment.svg);\n        else if (i === childFragments.length - 1) childrenSvg += $6b098df580cc3f14$var$renderTransformTranslateSvg(bottomAddWidth, currentY, childFragment.svg);\n        else childrenSvg += $6b098df580cc3f14$var$renderTransformTranslateSvg(offsetX, currentY, childFragment.svg);\n        // 接続線を描画 (最後のノード以外)\n        if (i < childFragments.length - 1) {\n            let startY = 0;\n            let endY = 0;\n            if (childFragment.type === \"Terminal\") {\n                if (i === 0) startY = currentY + childFragment.height;\n                else startY = currentY + childFragment.height / 2;\n            } else startY = currentY;\n            if (childFragments[i + 1].type === \"Terminal\") {\n                if (i + 1 === childFragments.length - 1) endY = currentY + childFragment.height + options.nodeListSpace;\n                else endY = currentY + childFragment.height + options.nodeListSpace + childFragments[i + 1].height / 2;\n            } else endY = currentY + childFragment.height + options.nodeListSpace + childFragments[i + 1].height;\n            childrenSvg += $6b098df580cc3f14$var$renderLineSvg(offsetX, startY, offsetX, endY, options);\n            totalHeight += options.nodeListSpace;\n        }\n        currentY += childFragment.height + options.nodeListSpace;\n    }\n    return {\n        svg: childrenSvg,\n        width: maxWidth + offsetX,\n        height: totalHeight,\n        type: \"NodeList\"\n    };\n}\n// == テキスト処理 ==\n/**\r\n * テキストのサイズを概算するヘルパー関数。\r\n * 全角文字と半角文字を考慮してテキストの幅を計算します。\r\n */ function $6b098df580cc3f14$var$measureTextSvg(text, options) {\n    const lines = text.split(\"\\n\");\n    const charWidth = options.fontSize; // 全角文字の幅を概算\n    const getCharWidth = (char)=>{\n        // 半角文字の正規表現\n        if (char.match(/^[\\u0020-\\u007e]*$/)) return 0.6;\n        // 全角文字\n        return 1.0;\n    };\n    const maxWidth = Math.max(...lines.map((line)=>{\n        let width = 0;\n        for (const char of line)width += getCharWidth(char);\n        return width * charWidth;\n    }));\n    const textHeight = lines.length * options.fontSize * options.lineHeight;\n    return {\n        width: maxWidth,\n        height: textHeight\n    };\n}\n/**\r\n * テキストをSVG形式で描画\r\n */ function $6b098df580cc3f14$var$renderTextSvg(text, posX, posY, options) {\n    const lines = text.split(\"\\n\");\n    let svg = \"\";\n    lines.forEach((line, index)=>{\n        const dy = index === 0 ? 0 : index * options.fontSize * options.lineHeight;\n        svg += `<text `;\n        svg += `x=\"${posX}\" y=\"${posY + options.fontSize}\" dy=\"${dy}\" `;\n        svg += `font-family=\"${options.fontFamily}\" `;\n        svg += `font-size=\"${options.fontSize}\" `;\n        svg += `fill=\"${options.textColor}\">${line}</text>`;\n    });\n    return svg;\n}\n// == 描画支援 ==\n/**\r\n * line描画支援\r\n */ function $6b098df580cc3f14$var$renderLineSvg(x1, y1, x2, y2, options) {\n    return `<line\n      x1=\"${x1}\" y1=\"${y1}\"\n      x2=\"${x2}\" y2=\"${y2}\"\n      stroke=\"${options.strokeColor}\"\n      stroke-width=\"${options.strokeWidth}\"\n    />`;\n}\n/**\r\n * 描画位置オフセット支援\r\n */ function $6b098df580cc3f14$var$renderTransformTranslateSvg(x, y, childSvg) {\n    return `<g transform=\"translate(${x}, ${y})\">${childSvg}</g>`;\n}\n\n\ndocument.addEventListener(\"DOMContentLoaded\", ()=>{\n    const spdInput = document.getElementById(\"spdInput\");\n    const svgOutput = document.getElementById(\"svgOutput\");\n    const fileInput = document.getElementById(\"fileInput\");\n    const downloadButton = document.getElementById(\"downloadButton\");\n    const downloadSvgButton = document.getElementById(\"downloadSvgButton\");\n    // Render Options\n    const fontSizeInput = document.getElementById(\"fontSizeInput\");\n    const baseBackgroundColorInput = document.getElementById(\"baseBackgroundColorInput\");\n    const transparentBackgroundCheckbox = document.getElementById(\"transparentBackgroundCheckbox\");\n    const backgroundColorInput = document.getElementById(\"backgroundColorInput\");\n    const transparentNodeBackgroundCheckbox = document.getElementById(\"transparentNodeBackgroundCheckbox\");\n    const textColorInput = document.getElementById(\"textColorInput\");\n    const listRenderTypeTerminalOffset = document.getElementById(\"listRenderTypeTerminalOffset\");\n    const applyOptionsButton = document.getElementById(\"applyOptionsButton\");\n    const convertAndRender = ()=>{\n        const spdText = spdInput.value;\n        try {\n            const ast = (0, $30ca700923f7cd7e$export$98e6a39c04603d36)(spdText);\n            const options = {\n                fontSize: parseInt(fontSizeInput.value, 10),\n                baseBackgroundColor: transparentBackgroundCheckbox.checked ? null : baseBackgroundColorInput.value,\n                backgroundColor: transparentNodeBackgroundCheckbox.checked ? null : backgroundColorInput.value,\n                textColor: textColorInput.value,\n                listRenderType: listRenderTypeTerminalOffset.checked ? \"TerminalOffset\" : \"Original\"\n            };\n            const svgString = (0, $6b098df580cc3f14$export$b3890eb0ae9dca99)(ast, options);\n            svgOutput.innerHTML = svgString;\n        } catch (error) {\n            if (error instanceof Error) {\n                svgOutput.innerHTML = `<p style=\"color: red;\">Error: ${error.message}</p>`;\n                console.error(\"SPD conversion error:\", error);\n            } else {\n                svgOutput.innerHTML = `<p style=\"color: red;\">An unknown error occurred</p>`;\n                console.error(\"An unknown error occurred:\", error);\n            }\n        }\n    };\n    transparentBackgroundCheckbox.addEventListener(\"change\", ()=>{\n        baseBackgroundColorInput.disabled = transparentBackgroundCheckbox.checked;\n    });\n    transparentNodeBackgroundCheckbox.addEventListener(\"change\", ()=>{\n        backgroundColorInput.disabled = transparentNodeBackgroundCheckbox.checked;\n    });\n    spdInput.addEventListener(\"input\", convertAndRender);\n    applyOptionsButton.addEventListener(\"click\", convertAndRender);\n    spdInput.addEventListener(\"keydown\", (event)=>{\n        if (event.key === \"Tab\") {\n            event.preventDefault(); // デフォルトのTabキーの動作（フォーカス移動）をキャンセル\n            const start = spdInput.selectionStart;\n            const end = spdInput.selectionEnd;\n            // タブ文字を挿入\n            spdInput.value = spdInput.value.substring(0, start) + \"\t\" + spdInput.value.substring(end);\n            // カーソル位置をタブの直後に設定\n            spdInput.selectionStart = spdInput.selectionEnd = start + 1;\n            convertAndRender(); // タブ挿入後も変換を実行\n        }\n    });\n    fileInput.addEventListener(\"change\", (event)=>{\n        const file = event.target.files?.[0];\n        if (file) {\n            const reader = new FileReader();\n            reader.onload = (e)=>{\n                spdInput.value = e.target?.result;\n                convertAndRender(); // ファイル読み込み後も変換を実行\n            };\n            reader.readAsText(file);\n        }\n    });\n    downloadButton.addEventListener(\"click\", ()=>{\n        const spdText = spdInput.value;\n        let fileName = prompt(\"\\u30C0\\u30A6\\u30F3\\u30ED\\u30FC\\u30C9\\u3059\\u308B\\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u3092\\u5165\\u529B\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044:\", \"edited_spd.spd\");\n        if (fileName === null) // ユーザーがキャンセルした場合\n        return;\n        // 拡張子がない場合は.spdを追加\n        if (!fileName.endsWith(\".spd\")) fileName += \".spd\";\n        const blob = new Blob([\n            spdText\n        ], {\n            type: \"text/plain\"\n        });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        a.href = url;\n        a.download = fileName; // ユーザーが入力したファイル名を使用\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    });\n    downloadSvgButton.addEventListener(\"click\", ()=>{\n        const svgString = svgOutput.innerHTML;\n        if (!svgString) {\n            alert(\"SVG\\u304C\\u751F\\u6210\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\\u3002\");\n            return;\n        }\n        let fileName = prompt(\"\\u30C0\\u30A6\\u30F3\\u30ED\\u30FC\\u30C9\\u3059\\u308BSVG\\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u3092\\u5165\\u529B\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044:\", \"output.svg\");\n        if (fileName === null) // ユーザーがキャンセルした場合\n        return;\n        // 拡張子がない場合は.svgを追加\n        if (!fileName.endsWith(\".svg\")) fileName += \".svg\";\n        const blob = new Blob([\n            svgString\n        ], {\n            type: \"image/svg+xml\"\n        });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        a.href = url;\n        a.download = fileName;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    });\n    // 初期表示用のサンプルSPDテキスト\n    spdInput.value = `:terminal \\u{958B}\\u{59CB}\n\\u{547D}\\u{4EE4}\n:comment \\u{30B3}\\u{30E1}\\u{30F3}\\u{30C8}\\u{6587}\n:call \\u{95A2}\\u{6570}\\u{547C}\\u{3073}\\u{51FA}\\u{3057}\n\t\\u{4E2D}\\u{8EAB}\n:if \\u{6761}\\u{4EF6}\\u{5F0F}\n\t\\u{771F}\\u{306E}\\u{5834}\\u{5408}\n:else\n\t\\u{507D}\\u{306E}\\u{5834}\\u{5408}(:else\\u{4EE5}\\u{4E0B}\\u{306F}\\u{7701}\\u{7565}\\u{53EF}\\u{80FD})\n:switch \\u{6761}\\u{4EF6}\n:case \\u{30B1}\\u{30FC}\\u{30B9}1\n\t\\u{30B1}\\u{30FC}\\u{30B9}1\\u{306E}\\u{4E2D}\\u{8EAB}\n:case \\u{30B1}\\u{30FC}\\u{30B9}2\n\t\\u{30B1}\\u{30FC}\\u{30B9}2\\u{306E}\\u{4E2D}\\u{8EAB}\n:case ...\n\t\\u{30B1}\\u{30FC}\\u{30B9}\\u{6587}\\u{306F}\\u{5FC5}\\u{8981}\\u{306B}\\u{5FDC}\\u{3058}\\u{3066}\\u{3044}\\u{304F}\\u{3064}\\u{3067}\\u{3082}\\u{8FFD}\\u{52A0}\\u{3067}\\u{304D}\\u{307E}\\u{3059}\n:while \\u{7E70}\\u{308A}\\u{8FD4}\\u{3057}\\u{6761}\\u{4EF6}\\u{FF08}\\u{5148}\\u{5224}\\u{5B9A}\\u{FF09}\n\t\\u{4E2D}\\u{8EAB}\n:dowhile \\u{7E70}\\u{308A}\\u{8FD4}\\u{3057}\\u{6761}\\u{4EF6}\\u{FF08}\\u{5F8C}\\u{5224}\\u{5B9A}\\u{FF09}\n\t\\u{4E2D}\\u{8EAB}\n:terminal \\u{7D42}\\u{4E86}`;\n    convertAndRender(); // ページロード時に一度変換を実行\n});\n\n\n//# sourceMappingURL=web.28622442.js.map\n","// web/src/main.ts\r\nimport { parse } from \"../../src/spd/parser\";\r\nimport { render as renderSvg } from \"../../src/spd/svg-renderer\";\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\", () => {\r\n\tconst spdInput = document.getElementById(\"spdInput\") as HTMLTextAreaElement;\r\n\tconst svgOutput = document.getElementById(\"svgOutput\") as HTMLDivElement;\r\n\tconst fileInput = document.getElementById(\"fileInput\") as HTMLInputElement;\r\n\tconst downloadButton = document.getElementById(\r\n\t\t\"downloadButton\",\r\n\t) as HTMLButtonElement;\r\n\tconst downloadSvgButton = document.getElementById(\r\n\t\t\"downloadSvgButton\",\r\n\t) as HTMLButtonElement;\r\n\r\n\t// Render Options\r\n\tconst fontSizeInput = document.getElementById(\r\n\t\t\"fontSizeInput\",\r\n\t) as HTMLInputElement;\r\n\tconst baseBackgroundColorInput = document.getElementById(\r\n\t\t\"baseBackgroundColorInput\",\r\n\t) as HTMLInputElement;\r\n\tconst transparentBackgroundCheckbox = document.getElementById(\r\n\t\t\"transparentBackgroundCheckbox\",\r\n\t) as HTMLInputElement;\r\n\tconst backgroundColorInput = document.getElementById(\r\n\t\t\"backgroundColorInput\",\r\n\t) as HTMLInputElement;\r\n\tconst transparentNodeBackgroundCheckbox = document.getElementById(\r\n\t\t\"transparentNodeBackgroundCheckbox\",\r\n\t) as HTMLInputElement;\r\n\tconst textColorInput = document.getElementById(\r\n\t\t\"textColorInput\",\r\n\t) as HTMLInputElement;\r\n\tconst listRenderTypeTerminalOffset = document.getElementById(\r\n\t\t\"listRenderTypeTerminalOffset\",\r\n\t) as HTMLInputElement;\r\n\tconst applyOptionsButton = document.getElementById(\r\n\t\t\"applyOptionsButton\",\r\n\t) as HTMLButtonElement;\r\n\r\n\tconst convertAndRender = () => {\r\n\t\tconst spdText = spdInput.value;\r\n\t\ttry {\r\n\t\t\tconst ast = parse(spdText);\r\n\t\t\tconst options = {\r\n\t\t\t\tfontSize: parseInt(fontSizeInput.value, 10),\r\n\t\t\t\tbaseBackgroundColor: transparentBackgroundCheckbox.checked\r\n\t\t\t\t\t? null\r\n\t\t\t\t\t: baseBackgroundColorInput.value,\r\n\t\t\t\tbackgroundColor: transparentNodeBackgroundCheckbox.checked\r\n\t\t\t\t\t? null\r\n\t\t\t\t\t: backgroundColorInput.value,\r\n\t\t\t\ttextColor: textColorInput.value,\r\n\t\t\t\tlistRenderType: listRenderTypeTerminalOffset.checked\r\n\t\t\t\t\t? \"TerminalOffset\"\r\n\t\t\t\t\t: \"Original\",\r\n\t\t\t};\r\n\t\t\tconst svgString = renderSvg(ast, options);\r\n\t\t\tsvgOutput.innerHTML = svgString;\r\n\t\t} catch (error) {\r\n\t\t\tif (error instanceof Error) {\r\n\t\t\t\tsvgOutput.innerHTML = `<p style=\"color: red;\">Error: ${error.message}</p>`;\r\n\t\t\t\tconsole.error(\"SPD conversion error:\", error);\r\n\t\t\t} else {\r\n\t\t\t\tsvgOutput.innerHTML = `<p style=\"color: red;\">An unknown error occurred</p>`;\r\n\t\t\t\tconsole.error(\"An unknown error occurred:\", error);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\ttransparentBackgroundCheckbox.addEventListener(\"change\", () => {\r\n\t\tbaseBackgroundColorInput.disabled = transparentBackgroundCheckbox.checked;\r\n\t});\r\n\r\n\ttransparentNodeBackgroundCheckbox.addEventListener(\"change\", () => {\r\n\t\tbackgroundColorInput.disabled = transparentNodeBackgroundCheckbox.checked;\r\n\t});\r\n\r\n\tspdInput.addEventListener(\"input\", convertAndRender);\r\n\tapplyOptionsButton.addEventListener(\"click\", convertAndRender);\r\n\r\n\tspdInput.addEventListener(\"keydown\", (event) => {\r\n\t\tif (event.key === \"Tab\") {\r\n\t\t\tevent.preventDefault(); // デフォルトのTabキーの動作（フォーカス移動）をキャンセル\r\n\t\t\tconst start = spdInput.selectionStart;\r\n\t\t\tconst end = spdInput.selectionEnd;\r\n\r\n\t\t\t// タブ文字を挿入\r\n\t\t\tspdInput.value =\r\n\t\t\t\tspdInput.value.substring(0, start) +\r\n\t\t\t\t\"\t\" +\r\n\t\t\t\tspdInput.value.substring(end);\r\n\r\n\t\t\t// カーソル位置をタブの直後に設定\r\n\t\t\tspdInput.selectionStart = spdInput.selectionEnd = start + 1;\r\n\r\n\t\t\tconvertAndRender(); // タブ挿入後も変換を実行\r\n\t\t}\r\n\t});\r\n\r\n\tfileInput.addEventListener(\"change\", (event) => {\r\n\t\tconst file = (event.target as HTMLInputElement).files?.[0];\r\n\t\tif (file) {\r\n\t\t\tconst reader = new FileReader();\r\n\t\t\treader.onload = (e) => {\r\n\t\t\t\tspdInput.value = e.target?.result as string;\r\n\t\t\t\tconvertAndRender(); // ファイル読み込み後も変換を実行\r\n\t\t\t};\r\n\t\t\treader.readAsText(file);\r\n\t\t}\r\n\t});\r\n\r\n\tdownloadButton.addEventListener(\"click\", () => {\r\n\t\tconst spdText = spdInput.value;\r\n\t\tlet fileName = prompt(\r\n\t\t\t\"ダウンロードするファイル名を入力してください:\",\r\n\t\t\t\"edited_spd.spd\",\r\n\t\t);\r\n\r\n\t\tif (fileName === null) {\r\n\t\t\t// ユーザーがキャンセルした場合\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// 拡張子がない場合は.spdを追加\r\n\t\tif (!fileName.endsWith(\".spd\")) {\r\n\t\t\tfileName += \".spd\";\r\n\t\t}\r\n\r\n\t\tconst blob = new Blob([spdText], { type: \"text/plain\" });\r\n\t\tconst url = URL.createObjectURL(blob);\r\n\t\tconst a = document.createElement(\"a\");\r\n\t\ta.href = url;\r\n\t\ta.download = fileName; // ユーザーが入力したファイル名を使用\r\n\t\tdocument.body.appendChild(a);\r\n\t\ta.click();\r\n\t\tdocument.body.removeChild(a);\r\n\t\tURL.revokeObjectURL(url);\r\n\t});\r\n\r\n\tdownloadSvgButton.addEventListener(\"click\", () => {\r\n\t\tconst svgString = svgOutput.innerHTML;\r\n\t\tif (!svgString) {\r\n\t\t\talert(\"SVGが生成されていません。\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet fileName = prompt(\r\n\t\t\t\"ダウンロードするSVGファイル名を入力してください:\",\r\n\t\t\t\"output.svg\",\r\n\t\t);\r\n\r\n\t\tif (fileName === null) {\r\n\t\t\t// ユーザーがキャンセルした場合\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// 拡張子がない場合は.svgを追加\r\n\t\tif (!fileName.endsWith(\".svg\")) {\r\n\t\t\tfileName += \".svg\";\r\n\t\t}\r\n\r\n\t\tconst blob = new Blob([svgString], { type: \"image/svg+xml\" });\r\n\t\tconst url = URL.createObjectURL(blob);\r\n\t\tconst a = document.createElement(\"a\");\r\n\t\ta.href = url;\r\n\t\ta.download = fileName;\r\n\t\tdocument.body.appendChild(a);\r\n\t\ta.click();\r\n\t\tdocument.body.removeChild(a);\r\n\t\tURL.revokeObjectURL(url);\r\n\t});\r\n\r\n\t// 初期表示用のサンプルSPDテキスト\r\n\tspdInput.value = `:terminal 開始\r\n命令\r\n:comment コメント文\r\n:call 関数呼び出し\r\n\t中身\r\n:if 条件式\r\n\t真の場合\r\n:else\r\n\t偽の場合(:else以下は省略可能)\r\n:switch 条件\r\n:case ケース1\r\n\tケース1の中身\r\n:case ケース2\r\n\tケース2の中身\r\n:case ...\r\n\tケース文は必要に応じていくつでも追加できます\r\n:while 繰り返し条件（先判定）\r\n\t中身\r\n:dowhile 繰り返し条件（後判定）\r\n\t中身\r\n:terminal 終了`;\r\n\tconvertAndRender(); // ページロード時に一度変換を実行\r\n});\r\n","import type {\r\n\tCallNode,\r\n\tCommentNode,\r\n\tIfNode,\r\n\tLoopNode,\r\n\tNode,\r\n\tNodeListNode,\r\n\tProcessNode,\r\n\tSwitchNode,\r\n\tTerminalNode,\r\n} from \"./ast\";\r\n\r\n// カスタムエラークラス群\r\nexport class ParseError extends Error {\r\n\tconstructor(message: string) {\r\n\t\tsuper(message);\r\n\t\tthis.name = this.constructor.name;\r\n\t}\r\n}\r\n// 引数が必要な場合にスローされる例外\r\nexport class RequireArgumentException extends ParseError {\r\n\tconstructor() {\r\n\t\tsuper(\"このコマンドは引数が必要です\");\r\n\t}\r\n}\r\n// 引数が不要な場合にスローされる例外\r\nexport class NotRequireArgumentException extends ParseError {\r\n\tconstructor() {\r\n\t\tsuper(\"このコマンドに引数は不要です\");\r\n\t}\r\n}\r\n// 不正なインデントの場合にスローされる例外\r\nexport class IllegalIndentException extends ParseError {\r\n\tconstructor() {\r\n\t\tsuper(\"インデントの数が不正です\");\r\n\t}\r\n}\r\n// 未知のコマンドの場合にスローされる例外\r\nexport class UnknownCommandException extends ParseError {\r\n\tconstructor() {\r\n\t\tsuper(\"未知のコマンドです\");\r\n\t}\r\n}\r\n// 予期しない:elseコマンドの場合にスローされる例外\r\nexport class UnexpectedElseException extends ParseError {\r\n\tconstructor() {\r\n\t\tsuper(\"不適切なelseです\");\r\n\t}\r\n}\r\n// 予期しない:caseコマンドの場合にスローされる例外\r\nexport class UnexpectedCaseException extends ParseError {\r\n\tconstructor() {\r\n\t\tsuper(\"不適切なcaseが現れました\");\r\n\t}\r\n}\r\n// :caseの値が重複している場合にスローされる例外\r\nexport class CaseDuplicateException extends ParseError {\r\n\tconstructor() {\r\n\t\tsuper(\"既に同名のCaseが存在します\");\r\n\t}\r\n}\r\n// 内部で予期しないエラーが発生した場合にスローされる例外\r\nexport class UnexpectedInnerException extends ParseError {\r\n\tconstructor(message: string) {\r\n\t\tsuper(`内部エラー:${message}`);\r\n\t}\r\n}\r\n// 予期しないI/Oエラーが発生した場合にスローされる例外\r\nexport class UnexpectedIOException extends ParseError {\r\n\tconstructor() {\r\n\t\tsuper(\"予期しないIOエラーが発生しました\");\r\n\t}\r\n}\r\n\r\ntype ParseErrorReceiverFunction = (\r\n\tlineStr: string,\r\n\tlineNo: number,\r\n\terr: ParseError,\r\n) => boolean;\r\n\r\n/**\r\n * パース中のコンテキストを扱うクラス。\r\n */\r\nclass Context {\r\n\t// 親のコンテキスト\r\n\tparent: Context | null = null;\r\n\t// 深さ\r\n\tdepth = 0;\r\n\t// ノードリスト\r\n\tnodeList: Node[] = [];\r\n\t// コンテキストの追加状態\r\n\toptionStatus: \"Default\" | \"Else\" = \"Default\";\r\n\t// コンテキストの状態に結びつく引数\r\n\toptionArg: string | null = null;\r\n}\r\n\r\n/**\r\n * SPD (Simple PAD Description) フォーマットのパーサー。\r\n */\r\n// コメントを判定する正規表現オブジェクト\r\nconst patternComment = /^\\s*(#.*)?$/;\r\n\r\nconst DummyParseErrorReceiver: ParseErrorReceiverFunction = (\r\n\t// lineStr: string,\r\n\t// lineNo: number,\r\n\t// err: ParseError,\r\n): boolean => {\r\n\treturn false;\r\n};\r\n\r\n/**\r\n * 本文を処理する\r\n * @param context 現在のコンテキスト\r\n * @param body 本文\r\n */\r\nconst handleBody = (context: Context, body: string): void => {\r\n\t// 状態の制御\r\n\tif (context.nodeList.length > 0) {\r\n\t\tconst lnode = context.nodeList[context.nodeList.length - 1];\r\n\t\tif (context.optionArg != null && lnode.type === \"switch\") {\r\n\t\t\tconst node: SwitchNode = lnode;\r\n\t\t\tnode.cases.set(context.optionArg, null);\r\n\t\t\tcontext.optionArg = null;\r\n\t\t}\r\n\t}\r\n\r\n\tif (body.startsWith(\":\")) {\r\n\t\tconst parts = body.split(/[ \\t]+/);\r\n\r\n\t\t// コマンド部分と引数部分を分離\r\n\t\tconst cmd = parts[0].substring(1); // コマンド名（例: \"call\", \"if\"）\r\n\t\tconst arg =\r\n\t\t\tparts.length > 1 ? body.substring(parts[0].length).trim() : null; // 引数\r\n\r\n\t\tswitch (cmd) {\r\n\t\t\tcase \"call\":\r\n\t\t\t\tif (!arg) throw new RequireArgumentException();\r\n\t\t\t\tcontext.nodeList.push({\r\n\t\t\t\t\ttype: \"call\",\r\n\t\t\t\t\ttext: arg,\r\n\t\t\t\t\tchildNode: null,\r\n\t\t\t\t} as CallNode);\r\n\t\t\t\tcontext.optionStatus = \"Default\";\r\n\t\t\t\tcontext.optionArg = null;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"terminal\":\r\n\t\t\t\tif (!arg) throw new RequireArgumentException();\r\n\t\t\t\tcontext.nodeList.push({\r\n\t\t\t\t\ttype: \"terminal\",\r\n\t\t\t\t\ttext: arg,\r\n\t\t\t\t} as TerminalNode);\r\n\t\t\t\tcontext.optionStatus = \"Default\";\r\n\t\t\t\tcontext.optionArg = null;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"comment\":\r\n\t\t\t\tif (!arg) throw new RequireArgumentException();\r\n\t\t\t\tcontext.nodeList.push({ type: \"comment\", text: arg } as CommentNode);\r\n\t\t\t\tcontext.optionStatus = \"Default\";\r\n\t\t\t\tcontext.optionArg = null;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"while\":\r\n\t\t\t\tif (!arg) throw new RequireArgumentException();\r\n\t\t\t\tcontext.nodeList.push({\r\n\t\t\t\t\ttype: \"loop\",\r\n\t\t\t\t\tisWhile: true,\r\n\t\t\t\t\ttext: arg,\r\n\t\t\t\t\tchildNode: null,\r\n\t\t\t\t} as LoopNode);\r\n\t\t\t\tcontext.optionStatus = \"Default\";\r\n\t\t\t\tcontext.optionArg = null;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"dowhile\":\r\n\t\t\t\tif (!arg) throw new RequireArgumentException();\r\n\t\t\t\tcontext.nodeList.push({\r\n\t\t\t\t\ttype: \"loop\",\r\n\t\t\t\t\tisWhile: false,\r\n\t\t\t\t\ttext: arg,\r\n\t\t\t\t\tchildNode: null,\r\n\t\t\t\t} as LoopNode);\r\n\t\t\t\tcontext.optionStatus = \"Default\";\r\n\t\t\t\tcontext.optionArg = null;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"if\":\r\n\t\t\t\tif (!arg) throw new RequireArgumentException();\r\n\t\t\t\tcontext.nodeList.push({\r\n\t\t\t\t\ttype: \"if\",\r\n\t\t\t\t\ttext: arg,\r\n\t\t\t\t\ttrueNode: null,\r\n\t\t\t\t\tfalseNode: null,\r\n\t\t\t\t} as IfNode);\r\n\t\t\t\tcontext.optionStatus = \"Default\";\r\n\t\t\t\tcontext.optionArg = null;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"switch\":\r\n\t\t\t\tif (!arg) throw new RequireArgumentException();\r\n\t\t\t\tcontext.nodeList.push({\r\n\t\t\t\t\ttype: \"switch\",\r\n\t\t\t\t\ttext: arg,\r\n\t\t\t\t\tcases: new Map<string, Node | null>(),\r\n\t\t\t\t} as SwitchNode);\r\n\t\t\t\tcontext.optionStatus = \"Default\";\r\n\t\t\t\tcontext.optionArg = null;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"else\": {\r\n\t\t\t\tconst lastIfNode =\r\n\t\t\t\t\tcontext.nodeList.length === 0\r\n\t\t\t\t\t\t? null\r\n\t\t\t\t\t\t: context.nodeList[context.nodeList.length - 1];\r\n\t\t\t\tif (lastIfNode === null || lastIfNode.type !== \"if\") {\r\n\t\t\t\t\tthrow new UnexpectedElseException();\r\n\t\t\t\t}\r\n\t\t\t\tif (arg !== null) {\r\n\t\t\t\t\tthrow new NotRequireArgumentException();\r\n\t\t\t\t}\r\n\t\t\t\tcontext.optionStatus = \"Else\";\r\n\t\t\t\tcontext.optionArg = null;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase \"case\": {\r\n\t\t\t\tconst lastSwitchNode =\r\n\t\t\t\t\tcontext.nodeList.length === 0\r\n\t\t\t\t\t\t? null\r\n\t\t\t\t\t\t: context.nodeList[context.nodeList.length - 1];\r\n\t\t\t\tif (lastSwitchNode === null || lastSwitchNode.type !== \"switch\") {\r\n\t\t\t\t\tthrow new UnexpectedCaseException();\r\n\t\t\t\t}\r\n\t\t\t\tif (!arg) throw new RequireArgumentException();\r\n\t\t\t\tif (lastSwitchNode.cases.has(arg)) {\r\n\t\t\t\t\tthrow new CaseDuplicateException();\r\n\t\t\t\t}\r\n\t\t\t\tcontext.optionStatus = \"Default\";\r\n\t\t\t\tcontext.optionArg = arg;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new UnknownCommandException();\r\n\t\t}\r\n\t} else {\r\n\t\tcontext.nodeList.push({\r\n\t\t\ttype: \"process\",\r\n\t\t\ttext: body,\r\n\t\t\tchildNode: null,\r\n\t\t} as ProcessNode);\r\n\t\tcontext.optionStatus = \"Default\";\r\n\t\tcontext.optionArg = null;\r\n\t}\r\n};\r\n\r\n/**\r\n * 現在のコンテキストを確定し、親コンテキストに移動します。\r\n * @param context 現在のコンテキスト。\r\n * @returns 親コンテキスト。\r\n */\r\nconst upToParent = (context: Context | null): Context | null => {\r\n\tif (context === null) return null;\r\n\r\n\t// 状態の制御\r\n\tif (context.nodeList.length > 0) {\r\n\t\tconst lnode = context.nodeList[context.nodeList.length - 1];\r\n\t\tif (context.optionArg != null && lnode.type === \"switch\") {\r\n\t\t\tconst node: SwitchNode = lnode as SwitchNode;\r\n\t\t\tnode.cases.set(context.optionArg, null);\r\n\t\t\tcontext.optionArg = null;\r\n\t\t}\r\n\t}\r\n\r\n\tif (context.parent === null) return null;\r\n\r\n\t// 追加するノードを新規作成。\r\n\tlet newNode: Node | NodeListNode | null = null;\r\n\tif (context.nodeList.length === 0) {\r\n\t\treturn context.parent;\r\n\t} else if (context.nodeList.length === 1) {\r\n\t\tnewNode = context.nodeList[0];\r\n\t} else {\r\n\t\tconst nodeList = { type: \"nodeList\", children: [] } as NodeListNode;\r\n\t\tfor (let i = 0; i < context.nodeList.length; i++) {\r\n\t\t\tnodeList.children.push(context.nodeList[i]);\r\n\t\t}\r\n\t\tnewNode = nodeList;\r\n\t}\r\n\r\n\t// ノードの追加先となるノード。\r\n\tconst pnode = context.parent.nodeList[context.parent.nodeList.length - 1];\r\n\r\n\t// ノードの種類に応じてノードの追加先に追加。\r\n\tswitch (pnode.type) {\r\n\t\tcase \"process\": {\r\n\t\t\tconst processNode = pnode as ProcessNode;\r\n\t\t\tprocessNode.childNode = newNode;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase \"loop\": {\r\n\t\t\tconst loopNode = pnode as LoopNode;\r\n\t\t\tloopNode.childNode = newNode;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase \"call\": {\r\n\t\t\tconst callNode = pnode as CallNode;\r\n\t\t\tcallNode.childNode = newNode;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase \"switch\": {\r\n\t\t\tconst snode = pnode as SwitchNode;\r\n\t\t\tif (context.parent.optionArg !== null) {\r\n\t\t\t\tsnode.cases.set(context.parent.optionArg, newNode);\r\n\t\t\t} else {\r\n\t\t\t\tthrow new UnexpectedInnerException(\r\n\t\t\t\t\t\"optionArg is null when it shouldn't be for switch node.\",\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase \"if\": {\r\n\t\t\tconst ifnode = pnode as IfNode;\r\n\t\t\tif (context.parent.optionStatus === \"Default\") {\r\n\t\t\t\tifnode.trueNode = newNode;\r\n\t\t\t} else if (context.parent.optionStatus === \"Else\") {\r\n\t\t\t\tif (ifnode.falseNode !== null) {\r\n\t\t\t\t\tthrow new UnexpectedElseException();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tifnode.falseNode = newNode;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t// 親ノードの状態をリセットする。\r\n\tcontext.parent.optionStatus = \"Default\";\r\n\tcontext.parent.optionArg = null;\r\n\r\n\t// 親ノードを返す。\r\n\treturn context.parent;\r\n};\r\n\r\n/**\r\n * SPDフォーマットの文字列をPADモデル（AST）にパースします。\r\n * @param src SPDフォーマットの文字列。\r\n * @returns パースされたASTのルートノード。\r\n */\r\nexport const parse = (\r\n\tsrc: string,\r\n\texr: ParseErrorReceiverFunction = DummyParseErrorReceiver,\r\n): Node | null => {\r\n\t// if(src == null) throw new IllegalArgumentException(\"src is null\"); // # diff TypeScriptではnullチェックは不要\r\n\r\n\t// 先頭のコンテキスト\r\n\tconst rootContext = new Context();\r\n\t// 現在のコンテキスト\r\n\tlet context: Context | null = rootContext;\r\n\r\n\t// １行づつ読み込む\r\n\t// ソースコードを行ごとに分割\r\n\tconst lines = src.split(/\\r?\\n/);\r\n\tlet lineNo = 0; // 現在の行番号\r\n\r\n\ttry {\r\n\t\twhile (lineNo < lines.length) {\r\n\t\t\tconst line = lines[lineNo];\r\n\t\t\tlineNo++;\r\n\r\n\t\t\t// コメント行は読み飛ばし\r\n\t\t\tif (patternComment.test(line)) continue;\r\n\r\n\t\t\t// 先頭のタブ数を数える。\r\n\t\t\tlet tabNum = 0;\r\n\t\t\tfor (let i = 0; i < line.length; ++i) {\r\n\t\t\t\tif (line.charAt(i) === \"\\t\") {\r\n\t\t\t\t\ttabNum++;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttry {\r\n\t\t\t\tif (context === null) {\r\n\t\t\t\t\tthrow new IllegalIndentException();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 子コンテキストの作成処理を行う。\r\n\t\t\t\tif ((tabNum > 0 && context.nodeList.length === 0) || tabNum < 0) {\r\n\t\t\t\t\t// 最初からタブがある場合は不正。\r\n\t\t\t\t\tthrow new IllegalIndentException();\r\n\t\t\t\t}\r\n\t\t\t\tif (tabNum > context.depth) {\r\n\t\t\t\t\t// タブが増加した場合の処理\r\n\r\n\t\t\t\t\t// 正当性をチェックする。\r\n\t\t\t\t\tconst parentNode = context.nodeList[context.nodeList.length - 1];\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\ttabNum > context.depth + 1 ||\r\n\t\t\t\t\t\t(parentNode && parentNode.type === \"comment\")\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\t// 親がコメントか２階層以上離れているのは不正。\r\n\t\t\t\t\t\tthrow new IllegalIndentException();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (parentNode.type === \"switch\" && context.optionArg == null) {\r\n\t\t\t\t\t\t// 子を持たないタイプの場合は不正。\r\n\t\t\t\t\t\tthrow new IllegalIndentException();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// 子コンテキストを生成する。\r\n\t\t\t\t\tconst newContext = new Context();\r\n\t\t\t\t\tnewContext.parent = context;\r\n\t\t\t\t\tnewContext.depth = context.depth + 1;\r\n\t\t\t\t\tcontext = newContext;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// タブが減少した際の処理\r\n\t\t\t\twhile (tabNum < context.depth) {\r\n\t\t\t\t\tcontext = upToParent(context);\r\n\t\t\t\t\tif (context === null) {\r\n\t\t\t\t\t\tthrow new IllegalIndentException();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 本文は行のデータをtrimしたものとする。\r\n\t\t\t\t// 行末が @ の場合は複数行扱いとする。\r\n\t\t\t\tlet body = line.substring(tabNum); // タブの後の本体部分を抽出\r\n\t\t\t\tif (body.endsWith(\"@\")) {\r\n\t\t\t\t\tlet multiLineContent = body.substring(0, body.length - 1);\r\n\t\t\t\t\twhile (lineNo < lines.length) {\r\n\t\t\t\t\t\tconst nextLine = lines[lineNo];\r\n\t\t\t\t\t\tlineNo++;\r\n\r\n\t\t\t\t\t\t// コメント行で止まる\r\n\t\t\t\t\t\tif (patternComment.test(nextLine)) continue;\r\n\r\n\t\t\t\t\t\t// 行末に @ が間読み込む\r\n\t\t\t\t\t\t// 行末に @ がある間読み込む\r\n\t\t\t\t\t\tlet nextLineTabNum = 0;\r\n\t\t\t\t\t\tfor (let i = 0; i < nextLine.length; ++i) {\r\n\t\t\t\t\t\t\tif (nextLine.charAt(i) === \"\\t\") {\r\n\t\t\t\t\t\t\t\tnextLineTabNum++;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tconst nextLineBody = nextLine.substring(nextLineTabNum);\r\n\r\n\t\t\t\t\t\tif (nextLineBody.endsWith(\"@\")) {\r\n\t\t\t\t\t\t\tmultiLineContent += `\\n${nextLineBody.substring(0, nextLineBody.length - 1)}`;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tmultiLineContent += `\\n${nextLineBody}`;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbody = multiLineContent;\r\n\t\t\t\t}\r\n\t\t\t\tbody = body.replace(/@/g, \"\\n\");\r\n\r\n\t\t\t\t// 本文を処理する。\r\n\t\t\t\tif (context !== null) {\r\n\t\t\t\t\thandleBody(context, body);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new IllegalIndentException(); // contextがnullの場合、これは不正な状態を示す\r\n\t\t\t\t}\r\n\t\t\t} catch (ex) {\r\n\t\t\t\tif (ex instanceof ParseError) {\r\n\t\t\t\t\tif (exr(line, lineNo - 1, ex)) {\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow ex;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow ex;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 先頭まで戻る\r\n\t\twhile (context != null) {\r\n\t\t\tcontext = upToParent(context);\r\n\t\t}\r\n\t} catch (ex) {\r\n\t\tif (ex instanceof ParseError) {\r\n\t\t\tthrow ex; // テストと適切なエラーハンドリングのためにParseErrorを再スロー\r\n\t\t} else {\r\n\t\t\tconsole.error(`行 ${lineNo} で予期しないエラーが発生しました: ${ex}`);\r\n\t\t\tthrow new ParseError(`予期しないエラー: ${ex}`); // その他のエラーをラップ\r\n\t\t}\r\n\t}\r\n\r\n\t// モデルを最終化して返す\r\n\tif (rootContext.nodeList.length === 0) {\r\n\t\treturn null;\r\n\t}\r\n\tconst topNode: NodeListNode = {\r\n\t\ttype: \"nodeList\",\r\n\t\tchildren: rootContext.nodeList,\r\n\t};\r\n\treturn topNode;\r\n};\r\n","import type {\r\n\tCallNode,\r\n\tCommentNode,\r\n\tIfNode,\r\n\tLoopNode,\r\n\tNode,\r\n\tNodeListNode,\r\n\tProcessNode,\r\n\tSwitchNode,\r\n\tTerminalNode,\r\n} from \"./ast\";\r\n\r\ntype Branch = {\r\n\tlabel: string;\r\n\tnode: Node | null;\r\n};\r\n\r\ntype BrancheNode = {\r\n\ttext: string;\r\n\ttype: \"If\" | \"Switch\";\r\n\tbranches: Branch[];\r\n};\r\n\r\ntype BoxNode = {\r\n\ttype: \"Comment\" | \"Process\" | \"Call\" | \"Loop\" | \"Terminal\";\r\n\ttext: string;\r\n\tchildNode: Node | null;\r\n\tborderType: \"None\" | \"Box\" | \"WRound\";\r\n\tdrawLeftBar: boolean;\r\n\tdrawRightBar: boolean;\r\n};\r\n\r\n/**\r\n * 描画に関する設定をまとめたオブジェクト\r\n */\r\ninterface RenderOptions {\r\n\tfontSize: number;\r\n\tfontFamily: string;\r\n\tmargin: { top: number; right: number; bottom: number; left: number };\r\n\tboxPadding: { top: number; right: number; bottom: number; left: number };\r\n\tbranchePadding: { top: number; right: number; bottom: number; left: number };\r\n\tstrokeWidth: number;\r\n\tstrokeColor: string;\r\n\tbackgroundColor: string | null;\r\n\tbaseBackgroundColor: string | null;\r\n\ttextColor: string;\r\n\tlineHeight: number;\r\n\tdoubleLineWidth: number; // 二重線の幅\r\n\tswitchNodeCaseWidth: number; // 分岐記号のギザギザの幅\r\n\tconnectorWidth: number; // 子ノードとの接続線幅\r\n\tnodeListSpace: number; // ノードListNodeの子ノード間のスペース\r\n\tchildNodeOffsetWidth: number;\r\n\tlistRenderType: string;\r\n}\r\n\r\n/**\r\n * 描画結果の中間表現\r\n * 各ノードを描画した結果、生成されるSVG文字列と、レイアウト計算に必要なサイズ情報を保持\r\n */\r\ninterface ViewFragment {\r\n\tsvg: string; // 生成されたSVG要素の文字列\r\n\twidth: number; // 全体の幅\r\n\theight: number; // 全体の高さ\r\n\ttype:\r\n\t\t| \"Process\"\r\n\t\t| \"Terminal\"\r\n\t\t| \"NodeList\"\r\n\t\t| \"Call\"\r\n\t\t| \"Loop\"\r\n\t\t| \"If\"\r\n\t\t| \"Switch\"\r\n\t\t| \"Comment\"\r\n\t\t| \"Unknown\"; // ノードのタイプ\r\n}\r\n\r\n// デフォルトの描画オプション\r\nconst defaultRenderOptions: RenderOptions = {\r\n\tfontSize: 14,\r\n\tfontFamily: \"sans-serif\",\r\n\tmargin: { top: 20, right: 20, bottom: 20, left: 20 },\r\n\tboxPadding: { top: 10, right: 10, bottom: 10, left: 10 },\r\n\tbranchePadding: { top: 5, right: 5, bottom: 5, left: 5 },\r\n\tstrokeWidth: 1,\r\n\tstrokeColor: \"#000000\",\r\n\tbackgroundColor: \"#ffffff\",\r\n\tbaseBackgroundColor: null,\r\n\ttextColor: \"#000000\",\r\n\tlineHeight: 1.2,\r\n\tdoubleLineWidth: 5,\r\n\tswitchNodeCaseWidth: 20,\r\n\tconnectorWidth: 2,\r\n\tnodeListSpace: 10,\r\n\tchildNodeOffsetWidth: 20,\r\n\tlistRenderType: \"original\",\r\n};\r\n\r\n/**\r\n * ASTを受け取り、完全なSVG文字列を返す\r\n */\r\nexport function render(\r\n\tnode: Node | null,\r\n\toptions?: Partial<RenderOptions>,\r\n): string {\r\n\tconst mergedOptions: RenderOptions = { ...defaultRenderOptions, ...options };\r\n\r\n\tif (!node) {\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\tconst fragment = renderNode(node, mergedOptions);\r\n\r\n\tconst svgWidth =\r\n\t\tfragment.width + mergedOptions.margin.left + mergedOptions.margin.right;\r\n\tconst svgHeight =\r\n\t\tfragment.height + mergedOptions.margin.top + mergedOptions.margin.bottom;\r\n\r\n\tlet svg = `<svg `;\r\n\tsvg += `width=\"${svgWidth}\" height=\"${svgHeight}\" `;\r\n\tsvg += `viewBox=\"0 0 ${svgWidth} ${svgHeight}\" `;\r\n\tsvg += `xmlns=\"http://www.w3.org/2000/svg\">`;\r\n\tconst baseFillColor = mergedOptions.baseBackgroundColor ?? \"none\";\r\n\tsvg += `<rect x=\"0\" y=\"0\" `;\r\n\tsvg += `width=\"${svgWidth}\" height=\"${svgHeight}\" `;\r\n\tsvg += `fill=\"${baseFillColor}\"/>`;\r\n\tsvg += renderTransformTranslateSvg(\r\n\t\tmergedOptions.margin.left,\r\n\t\tmergedOptions.margin.top,\r\n\t\tfragment.svg,\r\n\t);\r\n\tsvg += `</svg>`;\r\n\r\n\treturn svg;\r\n}\r\n\r\n/**\r\n * ASTのノード種別に応じて、対応する描画関数を呼び出す\r\n */\r\nfunction renderNode(node: Node, options: RenderOptions): ViewFragment {\r\n\tswitch (node.type) {\r\n\t\tcase \"process\":\r\n\t\t\treturn renderProcessFragment(node, options);\r\n\t\tcase \"terminal\":\r\n\t\t\treturn renderTerminalFragment(node, options);\r\n\t\tcase \"nodeList\":\r\n\t\t\treturn renderListFragment(node, options);\r\n\t\tcase \"call\":\r\n\t\t\treturn renderCallFragment(node, options);\r\n\t\tcase \"loop\":\r\n\t\t\treturn renderLoopFragment(node, options);\r\n\t\tcase \"if\":\r\n\t\t\treturn renderIfFragment(node, options);\r\n\t\tcase \"switch\":\r\n\t\t\treturn renderSwitchFragment(node, options);\r\n\t\tcase \"comment\":\r\n\t\t\treturn renderCommentFragment(node, options);\r\n\t\t// 他のノードタイプは後で追加\r\n\t\tdefault:\r\n\t\t\treturn { svg: \"\", width: 0, height: 0, type: \"Unknown\" }; // 未実装のノードタイプ\r\n\t}\r\n}\r\n\r\n/**\r\n * 箱型ノードの描画処理\r\n */\r\nfunction renderBoxFragment(\r\n\tnode: BoxNode,\r\n\toptions: RenderOptions,\r\n): ViewFragment {\r\n\tconst textMetrics = measureTextSvg(node.text, options);\r\n\tlet contentWidth = textMetrics.width;\r\n\tlet contentHeight = textMetrics.height;\r\n\tlet textOffsetX = options.boxPadding.left;\r\n\tlet textOffsetY = 0;\r\n\r\n\tlet svg = ``;\r\n\r\n\tif (node.borderType === \"Box\") {\r\n\t\t// 四角形のボックス\r\n\t\tcontentWidth += options.boxPadding.left + options.boxPadding.right;\r\n\t\tcontentHeight += options.boxPadding.top + options.boxPadding.bottom;\r\n\t\ttextOffsetY += options.boxPadding.top;\r\n\t\tconst fillColor = options.backgroundColor ?? \"none\";\r\n\t\tsvg += `<rect x=\"0\" y=\"0\" width=\"${contentWidth}\" height=\"${contentHeight}\" `;\r\n\t\tsvg += `stroke=\"${options.strokeColor}\" stroke-width=\"${options.strokeWidth}\" `;\r\n\t\tsvg += `fill=\"${fillColor}\"/>`;\r\n\t} else if (node.borderType === \"WRound\") {\r\n\t\t// 丸みを帯びた四角形\r\n\t\tcontentHeight += options.boxPadding.top + options.boxPadding.bottom;\r\n\t\ttextOffsetY += options.boxPadding.top;\r\n\t\tconst radius = contentHeight / 2; // 高さの半分を丸みの半径とする\r\n\t\tcontentWidth += contentHeight;\r\n\t\ttextOffsetX = radius;\r\n\t\tconst fillColor = options.backgroundColor ?? \"none\";\r\n\t\tsvg += `<rect x=\"0\" y=\"0\" width=\"${contentWidth}\" height=\"${contentHeight}\" `;\r\n\t\tsvg += `rx=\"${radius}\" ry=\"${radius}\" `;\r\n\t\tsvg += `stroke=\"${options.strokeColor}\" stroke-width=\"${options.strokeWidth}\" `;\r\n\t\tsvg += `fill=\"${fillColor}\"/>`;\r\n\t} else {\r\n\t\t// ボーダーなし\r\n\t\tcontentWidth += options.boxPadding.left + options.boxPadding.right;\r\n\t}\r\n\r\n\tif (node.drawLeftBar) {\r\n\t\t// 左側二重線\r\n\t\tsvg += renderLineSvg(\r\n\t\t\toptions.doubleLineWidth,\r\n\t\t\t0,\r\n\t\t\toptions.doubleLineWidth,\r\n\t\t\tcontentHeight,\r\n\t\t\toptions,\r\n\t\t);\r\n\t}\r\n\tif (node.drawRightBar) {\r\n\t\t// 右側二重線\r\n\t\tsvg += renderLineSvg(\r\n\t\t\tcontentWidth - options.doubleLineWidth,\r\n\t\t\t0,\r\n\t\t\tcontentWidth - options.doubleLineWidth,\r\n\t\t\tcontentHeight,\r\n\t\t\toptions,\r\n\t\t);\r\n\t}\r\n\r\n\tsvg += renderTextSvg(node.text, textOffsetX, textOffsetY, options);\r\n\r\n\tlet childFragment: ViewFragment | null = null;\r\n\tif (node.childNode) {\r\n\t\tchildFragment = renderNode(node.childNode, options);\r\n\t\tsvg += renderTransformTranslateSvg(\r\n\t\t\toptions.childNodeOffsetWidth + contentWidth,\r\n\t\t\t0,\r\n\t\t\tchildFragment.svg,\r\n\t\t);\r\n\t\tsvg += renderLineSvg(\r\n\t\t\tcontentWidth,\r\n\t\t\t0,\r\n\t\t\toptions.childNodeOffsetWidth + contentWidth,\r\n\t\t\t0,\r\n\t\t\toptions,\r\n\t\t);\r\n\t}\r\n\tconst totalWidth =\r\n\t\tcontentWidth +\r\n\t\t(childFragment ? childFragment.width + options.childNodeOffsetWidth : 0);\r\n\tconst totalHeight = Math.max(\r\n\t\tcontentHeight,\r\n\t\tchildFragment ? childFragment.height : 0,\r\n\t);\r\n\r\n\treturn {\r\n\t\tsvg: svg,\r\n\t\twidth: totalWidth,\r\n\t\theight: totalHeight,\r\n\t\ttype: node.type,\r\n\t};\r\n}\r\n\r\n/**\r\n * コメントノードの描画\r\n */\r\nfunction renderCommentFragment(\r\n\tnode: CommentNode,\r\n\toptions: RenderOptions,\r\n): ViewFragment {\r\n\tconst boxNode: BoxNode = {\r\n\t\ttype: \"Comment\",\r\n\t\ttext: `(${node.text})`,\r\n\t\tchildNode: null,\r\n\t\tborderType: \"None\",\r\n\t\tdrawLeftBar: false,\r\n\t\tdrawRightBar: false,\r\n\t};\r\n\treturn renderBoxFragment(boxNode, options);\r\n}\r\n\r\n/**\r\n * ループノードの描画\r\n */\r\nfunction renderLoopFragment(\r\n\tnode: LoopNode,\r\n\toptions: RenderOptions,\r\n): ViewFragment {\r\n\tconst boxNode: BoxNode = {\r\n\t\ttype: \"Loop\",\r\n\t\ttext: node.text,\r\n\t\tchildNode: node.childNode,\r\n\t\tborderType: \"Box\",\r\n\t\tdrawLeftBar: node.isWhile, // Whileループは左側に二重線を描画\r\n\t\tdrawRightBar: !node.isWhile, // Do-Whileループは右側に二重線を描画\r\n\t};\r\n\treturn renderBoxFragment(boxNode, options);\r\n}\r\n\r\n/**\r\n * 呼び出しノードの描画\r\n */\r\nfunction renderCallFragment(\r\n\tnode: CallNode,\r\n\toptions: RenderOptions,\r\n): ViewFragment {\r\n\tconst boxNode: BoxNode = {\r\n\t\ttype: \"Call\",\r\n\t\ttext: node.text,\r\n\t\tchildNode: node.childNode,\r\n\t\tborderType: \"Box\",\r\n\t\tdrawLeftBar: true,\r\n\t\tdrawRightBar: true,\r\n\t};\r\n\treturn renderBoxFragment(boxNode, options);\r\n}\r\n\r\n/**\r\n * 処理ノードの描画\r\n */\r\nfunction renderProcessFragment(\r\n\tnode: ProcessNode,\r\n\toptions: RenderOptions,\r\n): ViewFragment {\r\n\tconst boxNode: BoxNode = {\r\n\t\ttype: \"Process\",\r\n\t\ttext: node.text,\r\n\t\tchildNode: node.childNode,\r\n\t\tborderType: \"Box\",\r\n\t\tdrawLeftBar: false,\r\n\t\tdrawRightBar: false,\r\n\t};\r\n\treturn renderBoxFragment(boxNode, options);\r\n}\r\n\r\n/**\r\n * 端子ノードの描画\r\n */\r\nfunction renderTerminalFragment(\r\n\tnode: TerminalNode,\r\n\toptions: RenderOptions,\r\n): ViewFragment {\r\n\tconst boxNode: BoxNode = {\r\n\t\ttype: \"Terminal\",\r\n\t\ttext: node.text,\r\n\t\tchildNode: null,\r\n\t\tborderType: \"WRound\",\r\n\t\tdrawLeftBar: false,\r\n\t\tdrawRightBar: false,\r\n\t};\r\n\treturn renderBoxFragment(boxNode, options);\r\n}\r\n\r\n// == Branchノードの描画関数群 ===\r\n\r\nfunction measureTextSvgForBranche(\r\n\ttext: string,\r\n\toptions: RenderOptions,\r\n): { width: number; height: number } {\r\n\tconst textMetrics = measureTextSvg(text, options);\r\n\treturn {\r\n\t\twidth:\r\n\t\t\ttextMetrics.width +\r\n\t\t\toptions.branchePadding.left +\r\n\t\t\toptions.branchePadding.right,\r\n\t\theight:\r\n\t\t\ttextMetrics.height +\r\n\t\t\toptions.branchePadding.top +\r\n\t\t\toptions.branchePadding.bottom,\r\n\t};\r\n}\r\n\r\nfunction renderTextSvgForBranche(\r\n\ttext: string,\r\n\tposX: number,\r\n\tposY: number,\r\n\toptions: RenderOptions,\r\n): string {\r\n\treturn renderTextSvg(\r\n\t\ttext,\r\n\t\tposX + options.branchePadding.left,\r\n\t\tposY + options.branchePadding.top,\r\n\t\toptions,\r\n\t);\r\n}\r\n\r\n/**\r\n * 分岐ノードの描画\r\n */\r\nfunction renderBrancheFragment(\r\n\tnode: BrancheNode,\r\n\toptions: RenderOptions,\r\n): ViewFragment {\r\n\t// ケースの数が2未満の場合はダミーを追加する\r\n\tif (node.branches.length < 2) {\r\n\t\twhile (node.branches.length < 2) {\r\n\t\t\tnode.branches.push({ label: \"\", node: null });\r\n\t\t}\r\n\t}\r\n\r\n\tlet svg = \"\";\r\n\r\n\tconst conditionSize = measureTextSvgForBranche(node.text, options);\r\n\tconst minHeight = conditionSize.height;\r\n\r\n\tconst x = 0;\r\n\tconst y = 0;\r\n\r\n\t// labelw　<- ラベルの最大幅\r\n\t// h <- ラベルと、サブビューの合計値\r\n\t// subview <- サブビューの最大幅\r\n\tlet labelw = 0;\r\n\tlet subvieww = 0;\r\n\tlet h = 0;\r\n\r\n\tlet count = 0;\r\n\tlet lastdy = 0;\r\n\tlet lastldy = 0;\r\n\tconst brancheFragments: { label: string; fragment: ViewFragment | null }[] =\r\n\t\t[];\r\n\tconst ymap = new Map<number, number>();\r\n\tfor (const [index, branche] of node.branches.entries()) {\r\n\t\tconst label = branche.label;\r\n\t\tconst labelSize = measureTextSvgForBranche(label, options);\r\n\t\tconst brancheFragment = branche.node\r\n\t\t\t? renderNode(branche.node, options)\r\n\t\t\t: null;\r\n\r\n\t\t// サブビューがない場合はサイズ = 0\r\n\t\tconst subViewSize = brancheFragment\r\n\t\t\t? { width: brancheFragment.width, height: brancheFragment.height }\r\n\t\t\t: { width: 0, height: 0 };\r\n\r\n\t\tif (count !== node.branches.length - 1) {\r\n\t\t\tsubViewSize.height += options.nodeListSpace;\r\n\t\t}\r\n\r\n\t\tbrancheFragments.push({ label: label, fragment: brancheFragment });\r\n\r\n\t\t// ラベルの最大幅を更新\r\n\t\tif (labelw < labelSize.width) labelw = labelSize.width;\r\n\r\n\t\t// サブビューの最大幅を更新\r\n\t\tif (subvieww < subViewSize.width) subvieww = subViewSize.width;\r\n\r\n\t\t// ラベルに合わせて高さを更新\r\n\t\tlet uply: number, bottomly: number;\r\n\t\tif (count === 0) {\r\n\t\t\tuply = 0;\r\n\t\t\tbottomly = labelSize.height;\r\n\t\t} else if (count === node.branches.length - 1) {\r\n\t\t\tuply = labelSize.height;\r\n\t\t\tbottomly = 0;\r\n\t\t} else {\r\n\t\t\tuply = labelSize.height / 2;\r\n\t\t\tbottomly = uply;\r\n\t\t}\r\n\t\tif (lastdy < uply) lastdy += uply - lastdy;\r\n\r\n\t\t// ラベルが縦長い場合に調整\r\n\t\tconst minldy = lastldy > uply ? lastldy * 2 : uply * 2;\r\n\t\tlastldy = bottomly;\r\n\t\tif (minldy > lastdy) lastdy = minldy;\r\n\r\n\t\t// 高さを更新\r\n\t\th += lastdy;\r\n\t\tymap.set(index, h);\r\n\r\n\t\t// tmp <- 高さ追記分\r\n\t\tif (bottomly > subViewSize.height) {\r\n\t\t\tlastdy = bottomly;\r\n\t\t} else {\r\n\t\t\tlastdy = subViewSize.height;\r\n\t\t}\r\n\t\tif (lastdy < minHeight && count < node.branches.length - 1)\r\n\t\t\tlastdy = minHeight;\r\n\r\n\t\tcount += 1;\r\n\t}\r\n\r\n\th += lastdy;\r\n\r\n\t// 描画\r\n\r\n\t/**\r\n\t * A-----B1\r\n\t * |    /\r\n\t * |   C2\r\n\t * |    \\\r\n\t * |     B2\r\n\t * |    /\r\n\t * |   C3\r\n\t * |    \\\r\n\t * E-----B3\r\n\t */\r\n\tlet first = true;\r\n\tlet addChildLineWidth = false;\r\n\tconst poly: { x: number; y: number }[] = [];\r\n\tlet lasty = 0;\r\n\tconst boxRight =\r\n\t\tx + conditionSize.width + labelw + options.switchNodeCaseWidth;\r\n\tpoly.push({ x: x, y: y }); // Pos:A\r\n\tfor (const [index, brancheFragment] of brancheFragments.entries()) {\r\n\t\tconst lh_temp = ymap.get(index);\r\n\t\tconst lh = lh_temp ? lh_temp : 0;\r\n\t\tconst ly = y + lh;\r\n\r\n\t\tif (brancheFragment.fragment !== null) {\r\n\t\t\t// brancheFragment.fragment の描画\r\n\t\t\tsvg += renderTransformTranslateSvg(\r\n\t\t\t\tboxRight + options.childNodeOffsetWidth,\r\n\t\t\t\tly,\r\n\t\t\t\tbrancheFragment.fragment.svg,\r\n\t\t\t);\r\n\t\t\t// 小要素への line の描画\r\n\t\t\tsvg += renderLineSvg(\r\n\t\t\t\tboxRight,\r\n\t\t\t\tly,\r\n\t\t\t\tboxRight + options.childNodeOffsetWidth,\r\n\t\t\t\tly,\r\n\t\t\t\toptions,\r\n\t\t\t);\r\n\t\t\t// 小要素への line の分、最後に返す幅を増やす\r\n\t\t\taddChildLineWidth = true;\r\n\t\t}\r\n\r\n\t\tif (!first) {\r\n\t\t\t// Pos:C\r\n\t\t\tpoly.push({\r\n\t\t\t\tx: boxRight - options.switchNodeCaseWidth,\r\n\t\t\t\ty: (lasty + ly) / 2,\r\n\t\t\t});\r\n\t\t}\r\n\t\tpoly.push({ x: boxRight, y: ly }); // Pos:B\r\n\t\tfirst = false;\r\n\t\tlasty = ly;\r\n\t}\r\n\tpoly.push({ x: x, y: lasty }); // Pos:E\r\n\r\n\tconst polyPoints = poly.map((p) => `${p.x},${p.y}`).join(\" \");\r\n\r\n\t// polyの描画\r\n\tconst fillColor = options.backgroundColor ?? \"none\";\r\n\tsvg += `<polygon points=\"${polyPoints}\" `;\r\n\tsvg += `stroke=\"${options.strokeColor}\" `;\r\n\tsvg += `stroke-width=\"${options.strokeWidth}\" `;\r\n\tsvg += `fill=\"${fillColor}\"/>`;\r\n\r\n\tfor (const [index, brancheFragment] of brancheFragments.entries()) {\r\n\t\tconst label = brancheFragment.label;\r\n\t\tconst lh_temp = ymap.get(index);\r\n\t\tconst lh = lh_temp ? lh_temp : 0;\r\n\t\tlet ly = y + lh;\r\n\r\n\t\tconst ls = measureTextSvgForBranche(label, options);\r\n\r\n\t\tif (index >= node.branches.length - 1) {\r\n\t\t\tly -= ls.height;\r\n\t\t} else if (index > 0) {\r\n\t\t\tly -= ls.height / 2;\r\n\t\t}\r\n\r\n\t\t// label の描画\r\n\t\tsvg += renderTextSvgForBranche(\r\n\t\t\tlabel,\r\n\t\t\tx + conditionSize.width + labelw - ls.width,\r\n\t\t\tly,\r\n\t\t\toptions,\r\n\t\t);\r\n\t}\r\n\r\n\t// node.text の描画\r\n\tsvg += renderTextSvgForBranche(\r\n\t\tnode.text,\r\n\t\tx,\r\n\t\tlasty / 2 - conditionSize.height / 2,\r\n\t\toptions,\r\n\t);\r\n\r\n\treturn {\r\n\t\tsvg: svg,\r\n\t\twidth:\r\n\t\t\tboxRight +\r\n\t\t\tsubvieww +\r\n\t\t\t(addChildLineWidth ? options.childNodeOffsetWidth : 0),\r\n\t\theight: h,\r\n\t\ttype: node.type,\r\n\t};\r\n}\r\n\r\n/**\r\n * SWITCH分岐ノードの描画\r\n */\r\nfunction renderSwitchFragment(\r\n\tnode: SwitchNode,\r\n\toptions: RenderOptions,\r\n): ViewFragment {\r\n\tconst switchBrancheNode: BrancheNode = {\r\n\t\ttext: node.text,\r\n\t\ttype: \"Switch\",\r\n\t\tbranches: [],\r\n\t};\r\n\r\n\tfor (const [label, caseNode] of node.cases.entries()) {\r\n\t\tswitchBrancheNode.branches.push({\r\n\t\t\tlabel: label.toString(),\r\n\t\t\tnode: caseNode,\r\n\t\t});\r\n\t}\r\n\r\n\treturn renderBrancheFragment(switchBrancheNode, options);\r\n}\r\n\r\n/**\r\n * IF分岐ノードの描画\r\n */\r\nfunction renderIfFragment(node: IfNode, options: RenderOptions): ViewFragment {\r\n\tconst ifBrancheNode: BrancheNode = {\r\n\t\ttext: node.text,\r\n\t\ttype: \"If\",\r\n\t\tbranches: [],\r\n\t};\r\n\r\n\tif (node.trueNode) {\r\n\t\tifBrancheNode.branches.push({ label: \"\", node: node.trueNode });\r\n\t} else {\r\n\t\tifBrancheNode.branches.push({ label: \"\", node: null });\r\n\t}\r\n\r\n\tif (node.falseNode) {\r\n\t\tifBrancheNode.branches.push({ label: \"\", node: node.falseNode });\r\n\t} else {\r\n\t\tifBrancheNode.branches.push({ label: \"\", node: null });\r\n\t}\r\n\r\n\treturn renderBrancheFragment(ifBrancheNode, options);\r\n}\r\n\r\n// == ノード間の接続線の描画関数群 ===\r\n\r\n/**\r\n * 連結ノード（NodeListNode）の描画\r\n */\r\nfunction renderListFragment(\r\n\tnode: NodeListNode,\r\n\toptions: RenderOptions,\r\n): ViewFragment {\r\n\tif (options.listRenderType === \"TerminalOffset\") {\r\n\t\treturn renderListFragmentTerminalOffset(node, options);\r\n\t} else {\r\n\t\treturn renderListFragmentOriginal(node, options);\r\n\t}\r\n}\r\n\r\nfunction renderListFragmentOriginal(\r\n\tnode: NodeListNode,\r\n\toptions: RenderOptions,\r\n): ViewFragment {\r\n\tlet totalHeight = 0;\r\n\tlet maxWidth = 0;\r\n\tlet currentY = 0;\r\n\tlet childrenSvg = \"\";\r\n\tconst childFragments: ViewFragment[] = [];\r\n\r\n\t// 子ノードを再帰的に描画し、サイズとSVGを収集\r\n\tfor (const child of node.children) {\r\n\t\tconst childFragment = renderNode(child, options);\r\n\t\tchildFragments.push(childFragment);\r\n\t\ttotalHeight += childFragment.height;\r\n\t\tmaxWidth = Math.max(maxWidth, childFragment.width);\r\n\t}\r\n\r\n\t// 子ノードのSVGを配置し、接続線を描画\r\n\tfor (let i = 0; i < childFragments.length; i++) {\r\n\t\tconst childFragment = childFragments[i];\r\n\t\t// const xOffset = (maxWidth - childFragment.width) / 2; // 中央揃え\r\n\t\tchildrenSvg += renderTransformTranslateSvg(0, currentY, childFragment.svg);\r\n\r\n\t\t// 接続線を描画 (最後のノード以外)\r\n\t\tif (i < childFragments.length - 1) {\r\n\t\t\tlet startY = 0;\r\n\t\t\tlet endY = 0;\r\n\t\t\tif (childFragment.type === \"Terminal\") {\r\n\t\t\t\tstartY = currentY + childFragment.height / 2;\r\n\t\t\t} else {\r\n\t\t\t\tstartY = currentY;\r\n\t\t\t}\r\n\t\t\tif (childFragments[i + 1].type === \"Terminal\") {\r\n\t\t\t\tendY =\r\n\t\t\t\t\tcurrentY +\r\n\t\t\t\t\tchildFragment.height +\r\n\t\t\t\t\toptions.nodeListSpace +\r\n\t\t\t\t\tchildFragments[i + 1].height / 2;\r\n\t\t\t} else {\r\n\t\t\t\tendY =\r\n\t\t\t\t\tcurrentY +\r\n\t\t\t\t\tchildFragment.height +\r\n\t\t\t\t\toptions.nodeListSpace +\r\n\t\t\t\t\tchildFragments[i + 1].height;\r\n\t\t\t}\r\n\t\t\tchildrenSvg += renderLineSvg(0, startY, 0, endY, options);\r\n\t\t\ttotalHeight += options.nodeListSpace;\r\n\t\t}\r\n\t\tcurrentY += childFragment.height + options.nodeListSpace;\r\n\t}\r\n\r\n\treturn {\r\n\t\tsvg: childrenSvg,\r\n\t\twidth: maxWidth,\r\n\t\theight: totalHeight,\r\n\t\ttype: \"NodeList\",\r\n\t};\r\n}\r\n\r\nfunction renderListFragmentTerminalOffset(\r\n\tnode: NodeListNode,\r\n\toptions: RenderOptions,\r\n): ViewFragment {\r\n\tlet totalHeight = 0;\r\n\tlet maxWidth = 0;\r\n\tlet offsetX = 0;\r\n\tlet topAddWidth = 0;\r\n\tlet bottomAddWidth = 0;\r\n\tlet currentY = 0;\r\n\tlet childrenSvg = \"\";\r\n\tconst childFragments: ViewFragment[] = [];\r\n\r\n\t// 子ノードを再帰的に描画し、サイズとSVGを収集\r\n\tfor (const child of node.children) {\r\n\t\tconst childFragment = renderNode(child, options);\r\n\t\tchildFragments.push(childFragment);\r\n\t\ttotalHeight += childFragment.height;\r\n\t\tmaxWidth = Math.max(maxWidth, childFragment.width);\r\n\t}\r\n\r\n\tconst topChildFragment = childFragments[0];\r\n\tif (topChildFragment.type === \"Terminal\") {\r\n\t\tconst topWidth = topChildFragment.width;\r\n\t\toffsetX = topWidth / 2;\r\n\t}\r\n\tconst bottomChildFragment = childFragments[childFragments.length - 1];\r\n\tif (bottomChildFragment.type === \"Terminal\") {\r\n\t\tconst bottomWidth = bottomChildFragment.width;\r\n\t\tconst bottomOffset = bottomWidth / 2;\r\n\t\tif (bottomOffset > offsetX) {\r\n\t\t\ttopAddWidth = bottomOffset - offsetX;\r\n\t\t\toffsetX = bottomOffset;\r\n\t\t} else {\r\n\t\t\tbottomAddWidth = offsetX - bottomOffset;\r\n\t\t}\r\n\t}\r\n\r\n\t// 子ノードのSVGを配置し、接続線を描画\r\n\tfor (let i = 0; i < childFragments.length; i++) {\r\n\t\tconst childFragment = childFragments[i];\r\n\t\t// const xOffset = (maxWidth - childFragment.width) / 2; // 中央揃え\r\n\t\tif (i === 0) {\r\n\t\t\tchildrenSvg += renderTransformTranslateSvg(\r\n\t\t\t\ttopAddWidth,\r\n\t\t\t\tcurrentY,\r\n\t\t\t\tchildFragment.svg,\r\n\t\t\t);\r\n\t\t} else if (i === childFragments.length - 1) {\r\n\t\t\tchildrenSvg += renderTransformTranslateSvg(\r\n\t\t\t\tbottomAddWidth,\r\n\t\t\t\tcurrentY,\r\n\t\t\t\tchildFragment.svg,\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tchildrenSvg += renderTransformTranslateSvg(\r\n\t\t\t\toffsetX,\r\n\t\t\t\tcurrentY,\r\n\t\t\t\tchildFragment.svg,\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// 接続線を描画 (最後のノード以外)\r\n\t\tif (i < childFragments.length - 1) {\r\n\t\t\tlet startY = 0;\r\n\t\t\tlet endY = 0;\r\n\t\t\tif (childFragment.type === \"Terminal\") {\r\n\t\t\t\tif (i === 0) {\r\n\t\t\t\t\tstartY = currentY + childFragment.height;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstartY = currentY + childFragment.height / 2;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tstartY = currentY;\r\n\t\t\t}\r\n\t\t\tif (childFragments[i + 1].type === \"Terminal\") {\r\n\t\t\t\tif (i + 1 === childFragments.length - 1) {\r\n\t\t\t\t\tendY = currentY + childFragment.height + options.nodeListSpace;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tendY =\r\n\t\t\t\t\t\tcurrentY +\r\n\t\t\t\t\t\tchildFragment.height +\r\n\t\t\t\t\t\toptions.nodeListSpace +\r\n\t\t\t\t\t\tchildFragments[i + 1].height / 2;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tendY =\r\n\t\t\t\t\tcurrentY +\r\n\t\t\t\t\tchildFragment.height +\r\n\t\t\t\t\toptions.nodeListSpace +\r\n\t\t\t\t\tchildFragments[i + 1].height;\r\n\t\t\t}\r\n\t\t\tchildrenSvg += renderLineSvg(offsetX, startY, offsetX, endY, options);\r\n\t\t\ttotalHeight += options.nodeListSpace;\r\n\t\t}\r\n\t\tcurrentY += childFragment.height + options.nodeListSpace;\r\n\t}\r\n\r\n\treturn {\r\n\t\tsvg: childrenSvg,\r\n\t\twidth: maxWidth + offsetX,\r\n\t\theight: totalHeight,\r\n\t\ttype: \"NodeList\",\r\n\t};\r\n}\r\n\r\n// == テキスト処理 ==\r\n\r\n/**\r\n * テキストのサイズを概算するヘルパー関数。\r\n * 全角文字と半角文字を考慮してテキストの幅を計算します。\r\n */\r\nfunction measureTextSvg(\r\n\ttext: string,\r\n\toptions: RenderOptions,\r\n): { width: number; height: number } {\r\n\tconst lines = text.split(\"\\n\");\r\n\tconst charWidth = options.fontSize; // 全角文字の幅を概算\r\n\r\n\tconst getCharWidth = (char: string): number => {\r\n\t\t// 半角文字の正規表現\r\n\r\n\t\tif (char.match(/^[\\u0020-\\u007e]*$/)) {\r\n\t\t\treturn 0.6;\r\n\t\t}\r\n\t\t// 全角文字\r\n\t\treturn 1.0;\r\n\t};\r\n\r\n\tconst maxWidth = Math.max(\r\n\t\t...lines.map((line) => {\r\n\t\t\tlet width = 0;\r\n\t\t\tfor (const char of line) {\r\n\t\t\t\twidth += getCharWidth(char);\r\n\t\t\t}\r\n\t\t\treturn width * charWidth;\r\n\t\t}),\r\n\t);\r\n\r\n\tconst textHeight = lines.length * options.fontSize * options.lineHeight;\r\n\treturn { width: maxWidth, height: textHeight };\r\n}\r\n\r\n/**\r\n * テキストをSVG形式で描画\r\n */\r\nfunction renderTextSvg(\r\n\ttext: string,\r\n\tposX: number,\r\n\tposY: number,\r\n\toptions: RenderOptions,\r\n): string {\r\n\tconst lines = text.split(\"\\n\");\r\n\tlet svg = \"\";\r\n\tlines.forEach((line, index) => {\r\n\t\tconst dy = index === 0 ? 0 : index * options.fontSize * options.lineHeight;\r\n\t\tsvg += `<text `;\r\n\t\tsvg += `x=\"${posX}\" y=\"${posY + options.fontSize}\" dy=\"${dy}\" `;\r\n\t\tsvg += `font-family=\"${options.fontFamily}\" `;\r\n\t\tsvg += `font-size=\"${options.fontSize}\" `;\r\n\t\tsvg += `fill=\"${options.textColor}\">${line}</text>`;\r\n\t});\r\n\treturn svg;\r\n}\r\n\r\n// == 描画支援 ==\r\n\r\n/**\r\n * line描画支援\r\n */\r\nfunction renderLineSvg(\r\n\tx1: number,\r\n\ty1: number,\r\n\tx2: number,\r\n\ty2: number,\r\n\toptions: RenderOptions,\r\n): string {\r\n\treturn `<line\r\n      x1=\"${x1}\" y1=\"${y1}\"\r\n      x2=\"${x2}\" y2=\"${y2}\"\r\n      stroke=\"${options.strokeColor}\"\r\n      stroke-width=\"${options.strokeWidth}\"\r\n    />`;\r\n}\r\n\r\n/**\r\n * 描画位置オフセット支援\r\n */\r\nfunction renderTransformTranslateSvg(\r\n\tx: number,\r\n\ty: number,\r\n\tchildSvg: string,\r\n): string {\r\n\treturn `<g transform=\"translate(${x}, ${y})\">${childSvg}</g>`;\r\n}\r\n"],"names":["$30ca700923f7cd7e$export$f9c837a54db411d","Error","message","name","$30ca700923f7cd7e$export$eaf10ed6e5991cf8","$30ca700923f7cd7e$export$1d21b533e0dc3eed","$30ca700923f7cd7e$export$d0be8b16a0056b4a","$30ca700923f7cd7e$export$1e06c21ce32643dc","$30ca700923f7cd7e$export$91a4fa3e8e7c8586","$30ca700923f7cd7e$export$773fc764960da4ba","$30ca700923f7cd7e$export$a235ab136f3fda43","$30ca700923f7cd7e$export$ecfc75b1ea638281","$30ca700923f7cd7e$var$Context","parent","depth","nodeList","optionStatus","optionArg","$30ca700923f7cd7e$var$patternComment","$30ca700923f7cd7e$var$DummyParseErrorReceiver","$30ca700923f7cd7e$var$handleBody","context","body","length","lnode","type","node","cases","set","startsWith","parts","split","cmd","substring","arg","trim","push","text","childNode","isWhile","trueNode","falseNode","Map","lastIfNode","lastSwitchNode","has","$30ca700923f7cd7e$var$upToParent","newNode","children","i","pnode","processNode","snode","ifnode","$6b098df580cc3f14$var$defaultRenderOptions","fontSize","fontFamily","margin","top","right","bottom","left","boxPadding","branchePadding","strokeWidth","strokeColor","backgroundColor","baseBackgroundColor","textColor","lineHeight","doubleLineWidth","switchNodeCaseWidth","connectorWidth","nodeListSpace","childNodeOffsetWidth","listRenderType","$6b098df580cc3f14$var$renderNode","options","$6b098df580cc3f14$var$renderBoxFragment","borderType","drawLeftBar","drawRightBar","$6b098df580cc3f14$var$renderListFragmentTerminalOffset","totalHeight","maxWidth","offsetX","topAddWidth","bottomAddWidth","currentY","childrenSvg","childFragments","child","childFragment","height","Math","max","width","topChildFragment","topWidth","bottomChildFragment","bottomOffset","bottomWidth","$6b098df580cc3f14$var$renderTransformTranslateSvg","svg","startY","$6b098df580cc3f14$var$renderLineSvg","$6b098df580cc3f14$var$renderListFragmentOriginal","ifBrancheNode","branches","label","$6b098df580cc3f14$var$renderBrancheFragment","switchBrancheNode","caseNode","entries","toString","textMetrics","$6b098df580cc3f14$var$measureTextSvg","contentWidth","contentHeight","textOffsetX","textOffsetY","fillColor","radius","$6b098df580cc3f14$var$renderTextSvg","$6b098df580cc3f14$var$measureTextSvgForBranche","$6b098df580cc3f14$var$renderTextSvgForBranche","posX","posY","conditionSize","minHeight","labelw","subvieww","h","count","lastdy","lastldy","brancheFragments","ymap","index","branche","uply","bottomly","labelSize","brancheFragment","subViewSize","fragment","minldy","first","addChildLineWidth","poly","lasty","boxRight","x","y","ly","lh_temp","get","polyPoints","map","p","join","ls","lines","charWidth","getCharWidth","char","match","line","forEach","dy","x1","y1","x2","y2","childSvg","document","addEventListener","spdInput","getElementById","svgOutput","fileInput","downloadButton","downloadSvgButton","fontSizeInput","baseBackgroundColorInput","transparentBackgroundCheckbox","backgroundColorInput","transparentNodeBackgroundCheckbox","textColorInput","listRenderTypeTerminalOffset","applyOptionsButton","convertAndRender","spdText","value","ast","src","exr","rootContext","lineNo","test","tabNum","charAt","parentNode","newContext","endsWith","multiLineContent","nextLine","nextLineTabNum","nextLineBody","replace","ex","console","error","parseInt","checked","innerHTML","mergedOptions","svgWidth","svgHeight","baseFillColor","disabled","event","key","preventDefault","start","selectionStart","end","selectionEnd","file","target","files","reader","FileReader","onload","e","result","readAsText","fileName","prompt","blob","Blob","url","URL","createObjectURL","a","createElement","href","download","appendChild","click","removeChild","revokeObjectURL","svgString","alert"],"version":3,"file":"web.28622442.js.map"}